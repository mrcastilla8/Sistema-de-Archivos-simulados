{"C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\docs\\acl_paper\\main.tex": "\\documentclass[11pt]{article}\n\n\\usepackage[utf8]{inputenc}\n\\usepackage{graphicx}\n\\usepackage{booktabs}\n\\usepackage{url}\n\n\\title{Análisis de Esquemas de Asignación de Archivos: Contigua, Enlazada e Indexada}\n\\author{Autor 1 \\and Autor 2 \\and Autor 3 \\and Autor 4 \\and Autor 5}\n\\date{\\today}\n\n\\begin{document}\n\\maketitle\n\n\\begin{abstract}\nEstudio comparativo de tres políticas de asignación de archivos en un sistema simulado, evaluando tiempo de acceso, uso de espacio y fragmentación bajo distintos escenarios de carga.\n\\end{abstract}\n\n\\section{Introducción}\n\n\n\\section{Metodología}\n\\subsection{Algoritmos Implementados}\n\n\n\\subsection{Escenarios de Prueba}\n\n\n\\subsection{Métricas}\n\n\n\\section{Resultados y Discusión}\n\n\n\\section{Conclusiones}\n\n\n\\bibliographystyle{plain}\n\\bibliography{refs}\n\\end{document}\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\__main__.py": "\n\nfrom .cli .main import main \n\nif __name__ ==\"__main__\":\n    main ()\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\cli\\main.py": "import sys \nimport os \nimport platform \nimport json \nimport csv \nfrom pathlib import Path \nfrom typing import Dict ,Any ,List ,Callable ,Optional ,Tuple \n\n\ntry :\n    from ..sim .runner import run_simulation ,STRATEGIES \n    from ..sim .scenario_definitions import available_scenarios \nexcept ImportError :\n    print (\"Error: No se pudieron importar los módulos. Asegúrate de ejecutar como 'python -m src.fsim'\")\n    sys .exit (1 )\n\n\n\nSCENARIOS_JSON_PATH =\"data/scenarios.json\"\nRESULTS_DIR =Path (\"results\")\nMANIFEST_PREVIEW_COUNT =15 \n\n\nSTRATEGY_NAMES_ES ={\n\"contiguous\":\"Asignación Contigua\",\n\"linked\":\"Asignación Enlazada\",\n\"indexed\":\"Asignación Indexada\",\n}\nSCENARIO_NAMES_ES ={\n\"mix-small-large\":\"Mezcla Pequeños/Grandes\",\n\"seq-vs-rand\":\"Secuencial vs Aleatorio\",\n\"frag-intensive\":\"Fragmentación Intensiva\",\n}\n\n\n\n\n\n\ndef clear_screen ():\n    \"\"\"Limpia la pantalla de la terminal (multiplataforma).\"\"\"\n    if platform .system ()==\"Windows\":\n        os .system (\"cls\")\n    else :\n        os .system (\"clear\")\n\ndef print_header (title :str ):\n    \"\"\"Imprime un encabezado visualmente atractivo.\"\"\"\n    print (\"\\n\"+\"=\"*60 )\n    print (f\"    {title .upper ()}\")\n    print (\"=\"*60 )\n\ndef print_error (message :str ):\n    \"\"\"Imprime un mensaje de error estandarizado.\"\"\"\n    print (f\"\\n[ERROR]: {message }\")\n\ndef print_success (message :str ):\n    \"\"\"Imprime un mensaje de éxito estandarizado.\"\"\"\n    print (f\"\\n[EXITO]: {message }\")\n\ndef print_results (\nsummaries :Dict [str ,Any ],\nbitmaps :Dict [str ,List [int ]]\n):\n    \"\"\"\n    Imprime una tabla formateada con el resumen de métricas\n    Y el nuevo manifiesto de archivos (SOLICITUD 2).\n    \"\"\"\n    print (\"\\n\"+\"---\"*20 )\n    print (\"    RESUMEN DE METRICAS DE LA SIMULACION\")\n    print (\"---\"*20 )\n\n    for strategy ,metrics in summaries .items ():\n        spanish_name =STRATEGY_NAMES_ES .get (strategy ,strategy )\n        print (f\"\\n  Estrategia: {strategy .upper ()} ({spanish_name })\")\n\n\n        print (f\"    - Tiempo Acceso Prom.: {metrics .get ('avg_access_time_ms',0 ):.3f} ms\")\n        print (f\"    - Uso de Espacio:      {metrics .get ('space_usage_pct',0 ):.2f} %\")\n        print (f\"    - Frag. Externa:       {metrics .get ('fragmentation_external_pct',0 ):.2f} %\")\n        print (f\"    - Ops/Seg (Throughput): {metrics .get ('throughput_ops_per_sec',0 ):.2f}\")\n        print (f\"    - Total Seeks (Est.):  {metrics .get ('seeks_total_est',0 )}\")\n        print (f\"    - Tiempo Total Sim.:   {metrics .get ('elapsed_ms_total',0 ):.2f} ms\")\n\n        bitmap_len =len (bitmaps .get (strategy ,[]))\n        if bitmap_len >0 :\n            print (f\"    - (Bitmap final generado con {bitmap_len } bloques)\")\n\n\n        manifest =metrics .get (\"files_manifest\",[])\n        if manifest :\n            total_files =len (manifest )\n            alive_files =sum (1 for f in manifest if f .get (\"alive\"))\n\n            print (f\"    {'-'*64 }\")\n            print (f\"    MANIFEST DE ARCHIVOS (Total: {total_files }, Vivos: {alive_files })\")\n            print (f\"    {'-'*64 }\")\n\n\n            print (f\"    {'Nombre':<20} {'Tam (Blq)':<10} {'Estado':<10} {'Lecturas':<8} {'Escrituras':<10}\")\n\n\n            for f in manifest [:MANIFEST_PREVIEW_COUNT ]:\n                name =str (f .get (\"name\",\"?\"))[:18 ]\n                size =f .get (\"size_blocks\",0 )\n                status =\"Vivo\"if f .get (\"alive\")else \"Borrado\"\n                reads =f .get (\"read_ops\",0 )\n                writes =f .get (\"write_ops\",0 )\n\n                print (f\"    {name :<20} {size :<10} {status :<10} {reads :<8} {writes :<10}\")\n\n            if total_files >MANIFEST_PREVIEW_COUNT :\n                print (f\"    ... y {total_files -MANIFEST_PREVIEW_COUNT } archivos mas.\")\n\n    print (\"---\"*20 )\n\n    input (\"\\n... Presiona Enter para continuar ...\")\n\n\n\n\n\n\ndef _capture_manual_files_interactive ()->Optional [List [Dict [str ,Any ]]]:\n    \"\"\"Captura interactiva de archivos manuales.\"\"\"\n    clear_screen ()\n    print_header (\"Ingreso Interactivo de Archivos\")\n    user_files =[]\n\n    while True :\n        name =input (f\"  Nombre del archivo (deja vacio para terminar): \").strip ()\n        if not name :\n            break \n\n        size_str =input (f\"  Tamano en bloques para '{name }': \").strip ()\n        try :\n            size_blocks =int (size_str )\n            if size_blocks <=0 :\n                print_error (\"El tamano debe ser un entero mayor a 0.\")\n                continue \n\n            user_files .append ({\"name\":name ,\"size_blocks\":size_blocks })\n            print_success (f\"Archivo '{name }' (tam: {size_blocks }) agregado.\")\n\n        except ValueError :\n            print_error (\"Entrada invalida. El tamano debe ser un numero.\")\n\n    return user_files if user_files else None \n\ndef _capture_manual_files_import ()->Optional [List [Dict [str ,Any ]]]:\n    \"\"\"Captura de archivos manuales desde un archivo CSV o JSON.\"\"\"\n    clear_screen ()\n    print_header (\"Importar Archivos desde CSV/JSON\")\n    path_str =input (\"  Ruta al archivo (ej: 'data/mis_archivos.json' o 'data/mis_archivos.csv'): \").strip ()\n\n    user_files =[]\n\n    try :\n        path =Path (path_str )\n        if not path .exists ():\n            print_error (f\"El archivo no existe en: {path_str }\")\n            return None \n\n        with path .open (\"r\",encoding =\"utf-8\")as f :\n            if path_str .endswith (\".json\"):\n                data =json .load (f )\n                if not isinstance (data ,list ):\n                    print_error (\"El JSON debe ser una *lista* de objetos.\")\n                    return None \n\n                for i ,item in enumerate (data ):\n                    name =item .get (\"name\")\n                    size =item .get (\"size_blocks\")\n                    if not isinstance (name ,str )or not isinstance (size ,int )or size <=0 :\n                        print_error (f\"Error en JSON (item {i }): debe tener 'name' (str) y 'size_blocks' (int > 0).\")\n                        return None \n                    user_files .append ({\"name\":name ,\"size_blocks\":size })\n\n            elif path_str .endswith (\".csv\"):\n                reader =csv .DictReader (f )\n                for i ,row in enumerate (reader ):\n                    name =row .get (\"name\")\n                    size_str =row .get (\"size_blocks\")\n                    if not name or not size_str :\n                        print_error (f\"Error en CSV (fila {i +1 }): Faltan cabeceras 'name' o 'size_blocks'.\")\n                        return None \n\n                    try :\n                        size =int (size_str )\n                        if size <=0 :\n                            raise ValueError ()\n                        user_files .append ({\"name\":name ,\"size_blocks\":size })\n                    except ValueError :\n                        print_error (f\"Error en CSV (fila {i +1 }): 'size_blocks' ('{size_str }') debe ser un int > 0.\")\n                        return None \n            else :\n                print_error (\"Formato no soportado. Use .json o .csv\")\n                return None \n\n    except json .JSONDecodeError :\n        print_error (\"Error al parsear el JSON. Verifica la sintaxis.\")\n        return None \n    except FileNotFoundError :\n        print_error (f\"El archivo no existe en: {path_str }\")\n        return None \n    except Exception as e :\n        print_error (f\"Ocurrio un error inesperado al leer el archivo: {e }\")\n        return None \n\n    print_success (f\"Se importaron {len (user_files )} archivos exitosamente desde {path_str }.\")\n    return user_files if user_files else None \n\ndef _configure_workload ()->Optional [Tuple [Optional [List [Dict [str ,Any ]]],bool ,Optional [int ]]]:\n    \"\"\"\n    Paso interactivo para configurar la carga de trabajo (Aleatoria vs Manual).\n    Devuelve: (user_files, respect_user_files_only, seed) o None si se aborta.\n    \"\"\"\n    clear_screen ()\n    print_header (\"Configuracion de Carga de Trabajo\")\n    print (\"  1) Aleatorios\")\n    print (\"  2) Archivos Manuales\")\n\n    choice =input (\"Selecciona el tipo de carga de trabajo (1-2): \").strip ()\n\n    user_files :Optional [List [Dict [str ,Any ]]]=None \n    respect_user_files_only :bool =False \n\n    if choice ==\"1\":\n\n        pass \n\n    elif choice ==\"2\":\n\n        print (\"\\n  Como deseas ingresar los archivos manuales?\")\n        print (\"    1) Interactivamente (uno por uno)\")\n        print (\"    2) Importar desde archivo (CSV o JSON)\")\n\n        sub_choice =input (\"  Selecciona una opcion (1-2): \").strip ()\n        if sub_choice ==\"1\":\n            user_files =_capture_manual_files_interactive ()\n        elif sub_choice ==\"2\":\n            user_files =_capture_manual_files_import ()\n        else :\n            print_error (\"Opcion invalida.\")\n            return None \n\n        if not user_files :\n            print_error (\"No se ingresaron archivos manuales. Abortando simulacion.\")\n            return None \n\n        print (\"\\n  Como deben usarse estos archivos manuales?\")\n        print (\"    1) Solo usar manuales (ignorar aleatorios del escenario)\")\n        print (\"    2) Combinar (agregar manuales + aleatorios del escenario)\")\n\n        respect_choice =input (\"  Selecciona una opcion (1-2): \").strip ()\n        if respect_choice ==\"1\":\n            respect_user_files_only =True \n        elif respect_choice ==\"2\":\n            respect_user_files_only =False \n        else :\n            print_error (\"Opcion invalida.\")\n            return None \n\n    else :\n        print_error (\"Opcion invalida.\")\n        return None \n\n\n    seed_str =input (\"\\nIntroduce una 'seed' (semilla) numerica (ej. 42, o deja vacio para aleatorio): \")\n    seed =int (seed_str )if seed_str .isdigit ()else None \n\n    return user_files ,respect_user_files_only ,seed \n\n\n\n\n\n\ndef do_list_strategies ():\n    \"\"\"Opción 1: Muestra las estrategias disponibles.\"\"\"\n    print_header (\"Estrategias Soportadas\")\n    print (\"Estas son las estrategias que el Runner puede ejecutar:\")\n    for key in STRATEGIES .keys ():\n        spanish_name =STRATEGY_NAMES_ES .get (key ,key )\n        print (f\"  - {key } ({spanish_name })\")\n\ndef do_list_scenarios ():\n    \"\"\"Opción 2: Muestra los escenarios disponibles.\"\"\"\n    print_header (\"Escenarios Disponibles\")\n    print (f\"Cargando escenarios desde {SCENARIOS_JSON_PATH }...\")\n    try :\n        scens =available_scenarios (SCENARIOS_JSON_PATH )\n        if not scens :\n            print (\"  No se encontraron escenarios en DEFAULTS ni en el archivo JSON.\")\n            return \n        for name ,desc in scens .items ():\n            spanish_name =SCENARIO_NAMES_ES .get (name ,name )\n            print (f\"\\n  - {name } ({spanish_name }):\")\n            print (f\"      {desc }\")\n    except Exception as e :\n        print_error (f\"No se pudo cargar o leer '{SCENARIOS_JSON_PATH }': {e }\")\n\ndef do_run_simulation ():\n    \"\"\"Opción 3: Guía al usuario para ejecutar una simulación única.\"\"\"\n    clear_screen ()\n    print_header (\"Ejecutar Simulacion Unica\")\n\n\n    print (\"Estrategias disponibles:\")\n    strat_list =list (STRATEGIES .keys ())\n    for i ,s in enumerate (strat_list ):\n        spanish_name =STRATEGY_NAMES_ES .get (s ,s )\n        print (f\"  {i +1 }) {s } ({spanish_name })\")\n    try :\n        choice =int (input (\"Elige una estrategia (numero): \"))-1 \n        strategy_name =strat_list [choice ]\n    except (ValueError ,IndexError ):\n        print_error (\"Seleccion invalida.\")\n        return \n\n\n    print (\"\\nEscenarios disponibles:\")\n    try :\n        scen_map =available_scenarios (SCENARIOS_JSON_PATH )\n    except Exception as e :\n        print_error (f\"No se pudieron cargar escenarios: {e }\")\n        return \n    scen_list =list (scen_map .keys ())\n    for i ,s in enumerate (scen_list ):\n        spanish_name =SCENARIO_NAMES_ES .get (s ,s )\n        print (f\"  {i +1 }) {s } ({spanish_name })\")\n    try :\n        choice =int (input (\"Elige un escenario (numero): \"))-1 \n        scenario =scen_list [choice ]\n    except (ValueError ,IndexError ):\n        print_error (\"Seleccion invalida.\")\n        return \n\n\n    workload_config =_configure_workload ()\n    if workload_config is None :\n        return \n    user_files ,respect_only ,seed =workload_config \n\n\n    out_path =None \n    save_choice =input (f\"\\n¿Deseas guardar los resultados en un archivo? (s/n) [n]: \").lower ().strip ()\n    if save_choice =='s':\n        default_out =f\"run_{strategy_name }_{scenario }.json\"\n        out_file_str =input (f\"  Nombre del archivo (en 'results/'): [{default_out }] \")\n        if not out_file_str :\n            out_file_str =default_out \n        out_path =RESULTS_DIR /out_file_str \n\n    clear_screen ()\n    print (f\"\\nIniciando simulacion: {strategy_name } | {scenario } | seed={seed }...\")\n\n    try :\n\n        summaries ,bitmaps =run_simulation (\n        strategy_name =strategy_name ,\n        scenario =scenario ,\n        scenarios_path =SCENARIOS_JSON_PATH ,\n        seed =seed ,\n        overrides ={},\n        out =str (out_path )if out_path else None ,\n        user_files =user_files ,\n        respect_user_files_only =respect_only \n        )\n\n        if out_path :\n            print_success (f\"Simulacion completada. Resultados guardados en {out_path }\")\n        else :\n            print_success (\"Simulacion completada.\")\n\n\n        print_results (summaries ,bitmaps )\n\n    except Exception as e :\n        print_error (f\"La simulacion fallo: {e }\")\n\n        input (\"\\n... Presiona Enter para continuar ...\")\n\ndef do_run_sweep ():\n    \"\"\"Opción 4: Ejecuta un barrido de TODAS las estrategias en UN escenario.\"\"\"\n    clear_screen ()\n    print_header (\"Ejecutar Barrido (Sweep)\")\n    print (\"Este modo ejecutara 'TODAS' las estrategias en un solo escenario.\")\n\n\n    print (\"\\nEscenarios disponibles:\")\n    try :\n        scen_map =available_scenarios (SCENARIOS_JSON_PATH )\n    except Exception as e :\n        print_error (f\"No se pudieron cargar escenarios: {e }\")\n        return \n    scen_list =list (scen_map .keys ())\n    for i ,s in enumerate (scen_list ):\n        spanish_name =SCENARIO_NAMES_ES .get (s ,s )\n        print (f\"  {i +1 }) {s } ({spanish_name })\")\n    try :\n        choice =int (input (\"Elige un escenario para el barrido: \"))-1 \n        scenario =scen_list [choice ]\n    except (ValueError ,IndexError ):\n        print_error (\"Seleccion invalida.\")\n        return \n\n\n    workload_config =_configure_workload ()\n    if workload_config is None :\n        return \n    user_files ,respect_only ,seed =workload_config \n\n\n    default_out =f\"sweep_{scenario }.csv\"\n    out_file_str =input (f\"\\nNombre del archivo de resultados (en 'results/'): [{default_out }] \")\n    if not out_file_str :\n        out_file_str =default_out \n    out_path =RESULTS_DIR /out_file_str \n\n    clear_screen ()\n    print (f\"\\nIniciando BARRIDO: 'all' estrategias | {scenario } | seed={seed }...\")\n\n    try :\n\n        summaries ,bitmaps =run_simulation (\n        strategy_name =\"all\",\n        scenario =scenario ,\n        scenarios_path =SCENARIOS_JSON_PATH ,\n        seed =seed ,\n        overrides ={},\n        out =str (out_path ),\n        user_files =user_files ,\n        respect_user_files_only =respect_only \n        )\n        print_success (f\"Barrido completado. Resultados guardados en {out_path }\")\n\n\n        print_results (summaries ,bitmaps )\n\n    except Exception as e :\n        print_error (f\"El barrido fallo: {e }\")\n\n        input (\"\\n... Presiona Enter para continuar ...\")\n\ndef do_exit ():\n    \"\"\"Opción 5: Salir del programa.\"\"\"\n    clear_screen ()\n    print (\"\\nPrograma Finalizado\\n\")\n    sys .exit ()\n\ndef print_menu ():\n    \"\"\"Muestra el menú principal.\"\"\"\n    print_header (\"Simulador de Sistema de Archivos\")\n    print (\"  1. Listar estrategias disponibles\")\n    print (\"  2. Listar escenarios de prueba\")\n    print (\"  3. Ejecutar una simulacion unica\")\n    print (\"  4. Ejecutar un barrido (todas las estrategias en 1 escenario)\")\n    print (\"  5. Salir\")\n    print (\"-\"*60 )\n\n\n\n\n\n\ndef main ():\n    \"\"\"\n    Función principal que ejecuta el bucle del menú interactivo.\n    \"\"\"\n    try :\n        RESULTS_DIR .mkdir (parents =True ,exist_ok =True )\n    except OSError as e :\n        print_error (f\"No se pudo crear el directorio 'results': {e }\")\n        sys .exit (1 )\n\n    menu_options :Dict [str ,Callable [[],None ]]={\n    \"1\":do_list_strategies ,\n    \"2\":do_list_scenarios ,\n    \"3\":do_run_simulation ,\n    \"4\":do_run_sweep ,\n    \"5\":do_exit ,\n    }\n\n    while True :\n        clear_screen ()\n        print_menu ()\n        choice =input (\"Selecciona una opcion (1-5): \")\n\n        action =menu_options .get (choice )\n\n        if action :\n            clear_screen ()\n            action ()\n        else :\n            print_error (\"Opcion no valida.\")\n            input (\"\\n... Presiona Enter para continuar ...\")\n\n\n        if choice in (\"1\",\"2\"):\n            input (\"\\n... Presiona Enter para continuar ...\")\n\nif __name__ ==\"__main__\":\n    main ()\n\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\core\\block.py": "\nfrom __future__ import annotations \nfrom dataclasses import dataclass ,field \nfrom typing import Optional \n\n_ZERO =b\"\\x00\"\n\n\n@dataclass \nclass Block :\n    \"\"\"\n    Modelo de bloque lógico del 'disco' en memoria.\n\n    Diseño:\n      - Un bloque tiene un índice inmutable 'index' (posición en el disco).\n      - 'data' es opcional: None significa \"sin datos escritos\".\n        También puede ser 'b\"\"' (vacío) si quieres distinguir \"escrito con vacío\".\n      - No conoce el tamaño máximo del bloque por sí mismo; eso lo controla Disk.\n        (Disk ya valida que len(data) <= block_size en write_block()).\n\n    ¿Por qué este nivel?\n      - Mantener el estado por-bloque (datos + utilidades de conveniencia)\n        sin acoplarse a Disk ni a la política de asignación.\n      - Permitir inspección y operaciones sencillas en la UI (p. ej. mostrar\n        si un bloque está vacío, ver bytes escritos, etc.).\n    \"\"\"\n    index :int \n    data :Optional [bytes ]=field (default =None ,repr =False )\n\n\n\n\n\n    @property \n    def is_empty (self )->bool :\n        \"\"\"\n        Indica si no hay datos almacenados (None o cadena vacía).\n        - En esta simulación, None se usa comúnmente como \"nunca escrito\".\n        - b\"\" podría entenderse como \"escrito, pero vacío\".\n        \"\"\"\n        return self .data is None or len (self .data )==0 \n\n    @property \n    def size_bytes (self )->int :\n        \"\"\"\n        Tamaño actual del payload en bytes (0 si no hay datos).\n        \"\"\"\n        return 0 if self .data is None else len (self .data )\n\n\n\n\n\n\n    def clear (self )->None :\n        \"\"\"\n        Elimina el contenido del bloque (equivalente semántico a 'no escrito').\n        No lanza excepción.\n        \"\"\"\n        self .data =None \n\n    def set_bytes (self ,payload :Optional [bytes ])->None :\n        \"\"\"\n        Establece los bytes exactamente como llegan (sin validar tamaño).\n        ¡OJO! La validación de tamaño debe hacerla la capa 'Disk'.\n        Se ofrece para casos de uso fuera de Disk (e.g., UI o instrumentos).\n        \"\"\"\n        if payload is not None and not isinstance (payload ,(bytes ,bytearray ,memoryview )):\n            raise TypeError (\"payload debe ser bytes-like o None\")\n\n        self .data =None if payload is None else bytes (payload )\n\n    def fill_zeros (self ,block_size :int )->None :\n        \"\"\"\n        Rellena el bloque con 'block_size' bytes a cero (útil para demos/visual).\n        No valida contra 'Disk'; se asume que 'block_size' es correcto.\n        \"\"\"\n        if block_size <0 :\n            raise ValueError (\"block_size debe ser >= 0\")\n        self .data =_ZERO *block_size \n\n    def write_partial (\n    self ,\n    payload :bytes ,\n    *,\n    block_size :int |None =None ,\n    pad_with_zeros :bool =False ,\n    )->None :\n        \"\"\"\n        Escribe un payload parcial:\n          - Si 'block_size' es None: no se valida longitud (igual que set_bytes()).\n          - Si 'block_size' se especifica:\n              * Si len(payload) > block_size: ValueError.\n              * Si 'pad_with_zeros' es True y len(payload) < block_size:\n                    se rellena a la derecha con ceros hasta 'block_size'.\n              * Si 'pad_with_zeros' es False: se guarda tal cual.\n\n        Útil cuando quieras simular que el bloque físico tiene tamaño fijo\n        pero el contenido escrito puede ser menor (fragmentación interna visible).\n        \"\"\"\n        if not isinstance (payload ,(bytes ,bytearray ,memoryview )):\n            raise TypeError (\"payload debe ser bytes-like\")\n\n        raw =bytes (payload )\n\n        if block_size is not None :\n            if block_size <0 :\n                raise ValueError (\"block_size debe ser >= 0\")\n            if len (raw )>block_size :\n                raise ValueError (\n                f\"payload ({len (raw )} B) excede block_size ({block_size } B)\"\n                )\n            if pad_with_zeros and len (raw )<block_size :\n                raw =raw +(_ZERO *(block_size -len (raw )))\n\n        self .data =raw \n\n\n\n\n\n    def __repr__ (self )->str :\n        \"\"\"\n        Representación compacta para logs.\n        Mostrar solo un prefijo de los datos para no saturar la consola.\n        \"\"\"\n        preview_len =8 \n        if self .data is None :\n            d =\"None\"\n        else :\n\n            prefix =self .data [:preview_len ].hex ()\n            more =\"\"if len (self .data )<=preview_len else \"…\"\n            d =f\"{len (self .data )}B:{prefix }{more }\"\n        return f\"Block(index={self .index }, data={d })\"\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\core\\disk.py": "\nfrom __future__ import annotations \nfrom typing import Iterable ,List ,Optional ,Sequence \n\nfrom .block import Block \n\n\nclass Disk :\n    \"\"\"\n    Disco lógico en memoria.\n\n    Propiedades públicas (contrato DiskLike):\n      - n_blocks: int         → cantidad de bloques físicos\n      - block_size: int       → tamaño en bytes de cada bloque\n      - read_block(i)         → bytes | None\n      - write_block(i, data)  → None\n\n    Semántica:\n      - Un bloque puede estar en estado \"no escrito\" representado por `None`.\n      - Si se escribe `b\"\"` se considera \"escrito pero vacío\".\n      - La validación de longitud de `data` se hace acá (len(data) <= block_size).\n      - No simula latencias ni fallos; eso puede hacerse en capas superiores si se desea.\n    \"\"\"\n\n\n\n\n    def __init__ (\n    self ,\n    n_blocks :int ,\n    block_size :int ,\n    *,\n    prefill :Optional [str ]=None ,\n    )->None :\n        \"\"\"\n        Crea un disco lógico con `n_blocks` bloques de tamaño `block_size` bytes.\n\n        Args:\n            n_blocks: cantidad de bloques físicos (>= 1)\n            block_size: tamaño máximo en bytes por bloque (>= 1)\n            prefill:\n                - None (default): todos los bloques quedan como \"no escritos\" (data=None).\n                - \"zeros\": inicializa cada bloque con bytes nulos de longitud `block_size`.\n        \"\"\"\n        if n_blocks <=0 :\n            raise ValueError (\"n_blocks debe ser > 0\")\n        if block_size <=0 :\n            raise ValueError (\"block_size debe ser > 0\")\n\n        self .n_blocks :int =int (n_blocks )\n        self .block_size :int =int (block_size )\n\n        self ._storage :List [Block ]=[Block (i ,None )for i in range (self .n_blocks )]\n\n        if prefill is not None :\n            if prefill ==\"zeros\":\n                for b in self ._storage :\n                    b .fill_zeros (self .block_size )\n            else :\n                raise ValueError (\"prefill inválido. Usa None o 'zeros'.\")\n\n\n\n\n    def read_block (self ,i :int )->bytes |None :\n        \"\"\"\n        Devuelve los bytes del bloque `i` o None si nunca se escribió.\n        Errores:\n          - IndexError si `i` está fuera de rango.\n        \"\"\"\n        self ._check_index (i )\n        return self ._storage [i ].data \n\n    def write_block (self ,i :int ,data :bytes |None )->None :\n        \"\"\"\n        Escribe `data` en el bloque `i`.\n        Reglas:\n          - Si data es None → el bloque queda como \"no escrito\".\n          - Si data tiene más bytes que `block_size` → ValueError.\n          - Acepta bytes-like (bytes/bytearray/memoryview).\n\n        Errores:\n          - IndexError si `i` está fuera de rango.\n          - TypeError si `data` no es bytes-like ni None.\n          - ValueError si len(data) > block_size.\n        \"\"\"\n        self ._check_index (i )\n        if data is None :\n            self ._storage [i ].clear ()\n            return \n\n        if not isinstance (data ,(bytes ,bytearray ,memoryview )):\n            raise TypeError (\"data debe ser bytes-like o None\")\n\n\n        b =bytes (data )\n        if len (b )>self .block_size :\n            raise ValueError (\n            f\"Tamaño de data ({len (b )}) excede block_size ({self .block_size })\"\n            )\n\n        self ._storage [i ].set_bytes (b )\n\n\n\n\n    def clear_block (self ,i :int )->None :\n        \"\"\"Deja el bloque `i` como 'no escrito' (data=None).\"\"\"\n        self ._check_index (i )\n        self ._storage [i ].clear ()\n\n    def fill_block_zeros (self ,i :int )->None :\n        \"\"\"Rellena el bloque `i` con ceros (longitud = block_size).\"\"\"\n        self ._check_index (i )\n        self ._storage [i ].fill_zeros (self .block_size )\n\n    def read_blocks (self ,indices :Sequence [int ])->List [bytes |None ]:\n        \"\"\"\n        Lee múltiples bloques y devuelve una lista con sus contenidos.\n        Lanza IndexError si algún índice está fuera de rango.\n        \"\"\"\n        self ._check_indices (indices )\n        return [self ._storage [i ].data for i in indices ]\n\n    def write_blocks (self ,indices :Sequence [int ],payloads :Iterable [Optional [bytes ]])->None :\n        \"\"\"\n        Escribe múltiples bloques.\n        `indices` y `payloads` deben tener la misma longitud.\n        Valida tamaño de cada payload antes de escribir.\n\n        Errores:\n          - ValueError si longitudes no coinciden o payload excede block_size.\n          - IndexError si algún índice está fuera de rango.\n          - TypeError si algún payload no es bytes-like ni None.\n        \"\"\"\n        self ._check_indices (indices )\n        payloads_list =list (payloads )\n        if len (indices )!=len (payloads_list ):\n            raise ValueError (\"indices y payloads deben tener la misma longitud\")\n\n\n        for p in payloads_list :\n            if p is None :\n                continue \n            if not isinstance (p ,(bytes ,bytearray ,memoryview )):\n                raise TypeError (\"cada payload debe ser bytes-like o None\")\n            if len (p )>self .block_size :\n                raise ValueError (\n                f\"payload excede block_size ({len (p )} > {self .block_size })\"\n                )\n\n\n        for i ,p in zip (indices ,payloads_list ):\n            self .write_block (i ,p )\n\n    def used_blocks_count (self )->int :\n        \"\"\"\n        Cuenta cuántos bloques tienen 'data' no None (es decir, fueron escritos).\n        Útil para métricas de utilización física.\n        \"\"\"\n        return sum (1 for b in self ._storage if b .data is not None )\n\n    def empty_blocks_count (self )->int :\n        \"\"\"Bloques en estado 'no escrito' (data is None).\"\"\"\n        return self .n_blocks -self .used_blocks_count ()\n\n    def iter_blocks (self )->Iterable [Block ]:\n        \"\"\"\n        Iterador sobre los bloques físicos (útil para visualización en UI).\n        No retornar una copia para evitar overhead innecesario; manipular con cuidado.\n        \"\"\"\n        return iter (self ._storage )\n\n    def __len__ (self )->int :\n        \"\"\"Permite usar len(disk) == n_blocks.\"\"\"\n        return self .n_blocks \n\n\n\n\n    def _check_index (self ,i :int )->None :\n        if not isinstance (i ,int ):\n            raise TypeError (\"El índice de bloque debe ser int\")\n        if i <0 or i >=self .n_blocks :\n            raise IndexError (f\"Índice fuera de rango: {i } (0..{self .n_blocks -1 })\")\n\n    def _check_indices (self ,idxs :Sequence [int ])->None :\n        for i in idxs :\n            self ._check_index (i )\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\core\\filesystem_base.py": "from __future__ import annotations \n\nfrom abc import ABC ,abstractmethod \nfrom typing import (\nAny ,\nCallable ,\nDict ,\nIterable ,\nList ,\nOptional ,\nProtocol ,\nTuple ,\nruntime_checkable ,\n)\n\n\n\n\n\n\n@runtime_checkable \nclass DiskLike (Protocol ):\n    \"\"\"Interfaz mínima esperada de un disco lógico.\"\"\"\n    n_blocks :int \n    block_size :int \n\n    def read_block (self ,i :int )->bytes |None :...\n    def write_block (self ,i :int ,data :bytes |None )->None :...\n\n\n@runtime_checkable \nclass FreeSpaceManagerLike (Protocol ):\n    \"\"\"Interfaz mínima esperada del gestor de espacio libre.\"\"\"\n    n_blocks :int \n\n    def allocate (self ,n :int ,contiguous :bool =False )->List [int ]:...\n    def free (self ,block_list :List [int ])->None :...\n\n\n\n\n\n\nclass FilesystemBase (ABC ):\n    \"\"\"\n    Contrato base para las políticas de asignación (contigua, enlazada, indexada).\n\n    Unidades:\n      - `size_blocks`, `offset`, `n_blocks` están expresados en **bloques lógicos**.\n      - `block_size` (en el `disk`) está en **bytes** (solo relevante si simulan nivel de bytes).\n\n    Estado compartido:\n      - `self.disk`: provee E/S por bloque y capacidades (`n_blocks`, `block_size`).\n      - `self.fsm` : gestiona la reserva/liberación de bloques físicos.\n      - `self.file_table`: catálogo de archivos -> metadatos específicos de la estrategia.\n          * Debe contener, como mínimo:\n              - \"size_blocks\": int (tamaño lógico)\n          * La estrategia puede añadir lo que requiera (p. ej., \"start\"/\"length\", \"chain\", \"index_block\", \"data_blocks\").\n\n    Instrumentación:\n      - `on_event`: Callable opcional para reportar eventos al runner/metricador.\n        Se invoca con: on_event(event_type: str, **payload)\n        Ejemplos de `event_type`: \"create\", \"delete\", \"read\", \"write\".\n\n    Convenciones (recomendadas para el proyecto):\n      - Tamaños lógicos **fijos** por archivo (no crecer en `write`), para comparar\n        políticas de asignación sin introducir realocaciones. Si una estrategia decide\n        soportar crecimiento, debe documentarlo y respetar la interfaz igualmente.\n    \"\"\"\n\n\n\n\n\n    def __init__ (\n    self ,\n    disk :DiskLike ,\n    free_space_manager :FreeSpaceManagerLike ,\n    *,\n    on_event :Optional [Callable [[str ],None ]]|Optional [Callable [[str ,Any ],None ]]=None ,\n    )->None :\n\n        if not isinstance (disk ,DiskLike .__constraints__ if hasattr (DiskLike ,\"__constraints__\")else DiskLike ):\n\n            pass \n        if not hasattr (disk ,\"n_blocks\")or not hasattr (disk ,\"block_size\"):\n            raise TypeError (\"disk debe exponer 'n_blocks' y 'block_size'\")\n        if not hasattr (free_space_manager ,\"allocate\")or not hasattr (free_space_manager ,\"free\"):\n            raise TypeError (\"free_space_manager debe exponer 'allocate' y 'free'\")\n\n        self .disk :DiskLike =disk \n        self .fsm :FreeSpaceManagerLike =free_space_manager \n        self .file_table :Dict [str ,Dict [str ,Any ]]={}\n        self .on_event :Optional [Callable [...,None ]]=on_event \n\n    @property \n    def n_blocks (self )->int :\n        return self .disk .n_blocks \n\n    @property \n    def block_size (self )->int :\n        return self .disk .block_size \n\n\n\n\n\n    @abstractmethod \n    def create (self ,name :str ,size_blocks :int )->None :\n        \"\"\"\n        Crea un archivo lógico de 'size_blocks' bloques y reserva los bloques físicos necesarios\n        según la política de asignación.\n\n        Precondiciones:\n          - 'name' no debe existir en self.file_table.\n          - 'size_blocks' > 0 (o documentar si se permite 0).\n          - Debe existir espacio suficiente (y contiguo si la política lo exige).\n\n        Efectos:\n          - Reserva bloques en self.fsm (contiguos o dispersos).\n          - Inicializa metadata específica de la estrategia en self.file_table[name].\n          - Opcional: inicializar contenido de bloques (e.g., None o bytes vacíos).\n\n        Postcondiciones:\n          - El archivo figura en self.file_table con un mapeo lógico→físico válido.\n          - Los bloques reservados están marcados como ocupados en self.fsm.\n\n        Errores:\n          - FileExistsError si 'name' ya existe.\n          - MemoryError si no hay espacio suficiente (o contiguo en contigua).\n          - ValueError si 'size_blocks' es inválido.\n        \"\"\"\n        raise NotImplementedError \n\n    @abstractmethod \n    def delete (self ,name :str )->None :\n        \"\"\"\n        Elimina el archivo 'name', liberando todos sus bloques físicos (incluyendo bloque índice\n        en el caso de la política indexada, si aplica) y eliminando su metadata del catálogo.\n\n        Precondiciones:\n          - 'name' debe existir en self.file_table.\n\n        Efectos:\n          - Libera todos los bloques asignados a ese archivo mediante self.fsm.free(...).\n          - Elimina la entrada de self.file_table[name].\n\n        Postcondiciones:\n          - 'name' no aparece en self.file_table.\n          - Sus bloques quedan marcados como libres en self.fsm.\n\n        Errores:\n          - FileNotFoundError si 'name' no existe.\n        \"\"\"\n        raise NotImplementedError \n\n    @abstractmethod \n    def read (self ,name :str ,offset :int ,n_blocks :int ,access_mode :str =\"seq\")->List [bytes ]:\n        \"\"\"\n        Lee 'n_blocks' bloques lógicos a partir de 'offset' del archivo 'name' y devuelve\n        una lista de payloads (bytes). No debe modificar estado, solo simular el costo.\n\n        Precondiciones:\n          - 'name' debe existir.\n          - offset >= 0, n_blocks > 0.\n          - offset + n_blocks <= size_blocks (a menos que definas lectura parcial).\n\n        Efectos:\n          - Acceso a bloques físicos mediante mapeo lógico→físico de la política.\n          - Llamadas a self.disk.read_block(i) por cada bloque físico.\n          - Opcional: instrumentar “seeks”/saltos físicos en función del patrón.\n\n        Postcondiciones:\n          - No modifica self.file_table ni self.fsm.\n\n        Errores:\n          - FileNotFoundError, ValueError (rangos inválidos).\n        \"\"\"\n        raise NotImplementedError \n\n    @abstractmethod \n    def write (\n    self ,\n    name :str ,\n    offset :int ,\n    n_blocks :int ,\n    data :Iterable [bytes ]|None =None ,\n    )->None :\n        \"\"\"\n        Escribe 'n_blocks' a partir de 'offset' en el archivo 'name'. Puede sobrescribir bloques\n        existentes. Por defecto se recomienda tamaño lógico fijo (no crecer).\n\n        Precondiciones:\n          - 'name' debe existir.\n          - offset >= 0, n_blocks > 0.\n          - Si tamaño fijo: offset + n_blocks <= size_blocks.\n\n        Efectos:\n          - Resuelve mapeo lógico→físico y llama a self.disk.write_block(...) por bloque.\n          - Si 'data' es None, se permiten bytes sintéticos (e.g., b'' o zeros) según política.\n\n        Postcondiciones:\n          - El contenido físico de esos bloques refleja los nuevos datos.\n\n        Errores:\n          - FileNotFoundError, ValueError (rangos/datos).\n          - MemoryError si la política permite crecer y no hay espacio (no recomendado).\n        \"\"\"\n        raise NotImplementedError \n\n\n\n\n\n    @abstractmethod \n    def _resolve_range (self ,name :str ,offset :int ,n_blocks :int )->List [int ]:\n        \"\"\"\n        Debe ser implementado por la estrategia:\n        - Devuelve la lista de índices de bloques físicos que corresponden a los bloques\n          lógicos [offset, offset + n_blocks) del archivo 'name'.\n        - No realiza E/S; solo mapeo lógico→físico.\n\n        Errores:\n          - FileNotFoundError si 'name' no existe.\n          - ValueError si el rango es inválido o no representable por la estructura de la estrategia.\n        \"\"\"\n        raise NotImplementedError \n\n\n\n    def _assert_new_file (self ,name :str )->None :\n        if name in self .file_table :\n            raise FileExistsError (f\"El archivo '{name }' ya existe\")\n\n    def _assert_file_exists (self ,name :str )->None :\n        if name not in self .file_table :\n            raise FileNotFoundError (f\"El archivo '{name }' no existe\")\n\n    def _assert_positive_blocks (self ,n_blocks :int )->None :\n        if n_blocks <=0 :\n            raise ValueError (\"n_blocks debe ser > 0\")\n\n    def _assert_non_negative (self ,offset :int )->None :\n        if offset <0 :\n            raise ValueError (\"offset debe ser >= 0\")\n\n    def _assert_range_within_size (self ,name :str ,offset :int ,n_blocks :int )->None :\n        size =int (self .file_table [name ].get (\"size_blocks\",0 ))\n        if offset +n_blocks >size :\n            raise ValueError (\n            f\"Rango inválido: offset({offset }) + n_blocks({n_blocks }) > size_blocks({size })\"\n            )\n\n\n\n    def list_files (self )->List [Tuple [str ,int ]]:\n        \"\"\"\n        Devuelve [(name, size_blocks), ...] de todos los archivos registrados.\n        No garantiza orden.\n        \"\"\"\n        return [(k ,int (v .get (\"size_blocks\",0 )))for k ,v in self .file_table .items ()]\n\n    def get_file_info (self ,name :str )->Dict [str ,Any ]:\n        \"\"\"\n        Devuelve una copia superficial del metadata del archivo 'name'.\n        \"\"\"\n        self ._assert_file_exists (name )\n\n        return dict (self .file_table [name ])\n\n    def space_usage_summary (self )->Dict [str ,int ]:\n        \"\"\"\n        Resumen de uso de espacio (en bloques). Implementación genérica; el fsm puede\n        mantener su propio contador más eficiente, pero esto estandariza la salida.\n        \"\"\"\n        used =0 \n\n\n\n        for meta in self .file_table .values ():\n            used +=int (meta .get (\"size_blocks\",0 ))\n            used +=int (meta .get (\"overhead_blocks\",0 ))\n        return {\n        \"total_blocks\":self .n_blocks ,\n        \"used_blocks\":used ,\n        \"free_blocks\":max (0 ,self .n_blocks -used ),\n        }\n\n\n\n    def _emit (self ,event_type :str ,**payload :Any )->None :\n        \"\"\"\n        Notifica un evento (create|delete|read|write|...) al 'runner' o a quien consuma\n        métricas. La estrategia puede llamarlo antes/después de su operación principal.\n\n        Ejemplos:\n            self._emit(\"create\", name=name, size_blocks=size, allocated=idxs)\n            self._emit(\"read\", name=name, offset=offset, n_blocks=n, physical=phys_idxs)\n        \"\"\"\n        if self .on_event is not None :\n            try :\n                self .on_event (event_type ,**payload )\n            except TypeError :\n\n                self .on_event (event_type )\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\core\\free_space.py": "\nfrom __future__ import annotations \n\nfrom typing import Iterable ,List ,Sequence ,Tuple ,Optional ,Callable \n\n\nclass FreeSpaceManager :\n    \"\"\"\n    Gestor de espacio libre basado en un bitmap.\n    ...\n    \"\"\"\n\n\n\n\n\n    def __init__ (\n    self ,\n    n_blocks :int ,\n    *,\n    preoccupied :Optional [Sequence [int ]]=None ,\n    on_bitmap_update :Optional [Callable [[List [int ]],None ]]=None \n    )->None :\n\n        if n_blocks <=0 :\n            raise ValueError (\"n_blocks debe ser > 0\")\n        self .n_blocks :int =int (n_blocks )\n        self .bitmap :List [int ]=[0 ]*self .n_blocks \n\n\n        self .on_bitmap_update =on_bitmap_update \n\n\n        if preoccupied :\n            self ._check_indices (preoccupied )\n            for i in preoccupied :\n                self ._set_used (i )\n\n\n\n\n    def allocate (self ,n :int ,contiguous :bool =False )->List [int ]:\n        \"\"\"\n        Reserva 'n' bloques y devuelve sus índices físicos.\n        ...\n        \"\"\"\n        if n <=0 :\n            raise ValueError (\"n debe ser > 0\")\n\n        indices :List [int ]=[]\n\n        if contiguous :\n            run =self ._find_first_fit_run (n )\n            if run is None :\n                raise MemoryError (\"No hay espacio contiguo suficiente\")\n            start ,length =run \n            indices =list (range (start ,start +n ))\n            for i in indices :\n                self ._set_used (i )\n        else :\n\n            for i ,bit in enumerate (self .bitmap ):\n                if bit ==0 :\n                    indices .append (i )\n                    if len (indices )==n :\n                        break \n            if len (indices )<n :\n                raise MemoryError (\"No hay bloques libres suficientes\")\n            for i in indices :\n                self ._set_used (i )\n\n\n        if self .on_bitmap_update :\n            self .on_bitmap_update (self .bitmap )\n\n\n        return indices \n\n    def free (self ,block_list :List [int ])->None :\n        \"\"\"\n        Libera todos los bloques en 'block_list'.\n        ...\n        \"\"\"\n        if not block_list :\n            return \n        self ._check_indices (block_list )\n\n        if len (set (block_list ))!=len (block_list ):\n            raise ValueError (\"La lista de bloques a liberar contiene duplicados\")\n\n        for i in block_list :\n            if self .bitmap [i ]==0 :\n                raise ValueError (f\"El bloque {i } ya está libre (posible doble liberación)\")\n\n        for i in block_list :\n            self ._set_free (i )\n\n\n        if self .on_bitmap_update :\n            self .on_bitmap_update (self .bitmap )\n\n\n\n\n\n\n    def _find_first_fit_run (self ,needed :int )->Optional [Tuple [int ,int ]]:\n        \"\"\"\n        Devuelve (start, length) del primer run contiguo libre con length >= needed,\n        o None si no existe.\n        \"\"\"\n        run_len =0 \n        run_start =0 \n        for i ,bit in enumerate (self .bitmap ):\n            if bit ==0 :\n                if run_len ==0 :\n                    run_start =i \n                run_len +=1 \n                if run_len >=needed :\n                    return (run_start ,run_len )\n            else :\n                run_len =0 \n        return None \n\n    def _set_used (self ,i :int )->None :\n        self .bitmap [i ]=1 \n\n    def _set_free (self ,i :int )->None :\n        self .bitmap [i ]=0 \n\n\n\n\n    def _check_index (self ,i :int )->None :\n        if not isinstance (i ,int ):\n            raise TypeError (\"El índice debe ser int\")\n        if i <0 or i >=self .n_blocks :\n            raise IndexError (f\"Índice fuera de rango: {i } (0..{self .n_blocks -1 })\")\n\n    def _check_indices (self ,idxs :Sequence [int ])->None :\n        for i in idxs :\n            self ._check_index (i )\n\n\n\n\n    def used_count (self )->int :\n        \"\"\"Bloques ocupados (bitmap=1).\"\"\"\n        return sum (self .bitmap )\n\n    def free_count (self )->int :\n        \"\"\"Bloques libres (bitmap=0).\"\"\"\n        return self .n_blocks -self .used_count ()\n\n    def occupancy_pct (self )->float :\n        \"\"\"Porcentaje de ocupación física (0..100).\"\"\"\n        if self .n_blocks ==0 :\n            return 0.0 \n        return 100.0 *(self .used_count ()/self .n_blocks )\n\n    def free_runs (self )->List [Tuple [int ,int ]]:\n        \"\"\"\n        Lista de runs libres [(start, length), ...], en orden de aparición.\n        Útil para visualizar fragmentación externa.\n        \"\"\"\n        runs :List [Tuple [int ,int ]]=[]\n        run_len =0 \n        run_start =0 \n        for i ,bit in enumerate (self .bitmap ):\n            if bit ==0 :\n                if run_len ==0 :\n                    run_start =i \n                run_len +=1 \n            else :\n                if run_len >0 :\n                    runs .append ((run_start ,run_len ))\n                run_len =0 \n        if run_len >0 :\n            runs .append ((run_start ,run_len ))\n        return runs \n\n    def largest_free_run_size (self )->int :\n        \"\"\"Tamaño del mayor hueco contiguo libre.\"\"\"\n        runs =self .free_runs ()\n        return 0 if not runs else max (length for _ ,length in runs )\n\n    def external_fragmentation_ratio (self )->float :\n        \"\"\"\n        Heurística común de fragmentación externa:\n          - Si no hay bloques libres → 0.0\n          - Si hay libres → 1 - (largest_free_run / total_free)\n            (cuanto más cerca de 1.0, más fragmentado está el espacio libre)\n        \"\"\"\n        total_free =self .free_count ()\n        if total_free ==0 :\n            return 0.0 \n        largest =self .largest_free_run_size ()\n        return 1.0 -(largest /total_free )\n\n    def snapshot_bitmap (self )->List [int ]:\n        \"\"\"Copia superficial del bitmap (para inspección/serialización).\"\"\"\n        return list (self .bitmap )\n\n\n\n\n    def reserve_exact (self ,indices :Sequence [int ])->None :\n        \"\"\"\n        Marca como usados los índices indicados (útil cuando la estrategia\n        ya decidió qué bloques usar). Falla si alguno ya estaba ocupado.\n        \"\"\"\n        self ._check_indices (indices )\n\n        for i in indices :\n            if self .bitmap [i ]==1 :\n                raise ValueError (f\"El bloque {i } ya está ocupado\")\n        for i in indices :\n            self ._set_used (i )", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\fs_strategies\\contiguous.py": "\nfrom __future__ import annotations \nfrom typing import Iterable ,List ,Any ,Dict \nfrom ..core .filesystem_base import FilesystemBase \n\n\nclass ContiguousFS (FilesystemBase ):\n    \"\"\"\n    Estrategia de **asignación contigua**.\n\n    Metadata esperada en self.file_table[name]:\n      {\n        \"size_blocks\": int,\n        \"start\": int,        # primer bloque físico\n        \"length\": int,       # == size_blocks (si tamaño fijo)\n        (Opcional) \"overhead_blocks\": 0\n      }\n    \"\"\"\n\n\n\n\n    def create (self ,name :str ,size_blocks :int )->None :\n        self ._assert_new_file (name )\n        self ._assert_positive_blocks (size_blocks )\n\n        self ._emit (\"create:start\",strategy =\"contiguous\",name =name ,size_blocks =size_blocks )\n\n\n        try :\n            indices =self .fsm .allocate (size_blocks ,contiguous =True )\n        except MemoryError :\n            raise MemoryError (f\"No hay espacio contiguo suficiente para '{name }'\")\n\n        start =indices [0 ]\n\n\n        self .file_table [name ]={\n        \"size_blocks\":size_blocks ,\n        \"start\":start ,\n        \"length\":size_blocks ,\n        \"overhead_blocks\":0 ,\n        }\n\n\n        for i in indices :\n            self .disk .write_block (i ,None )\n\n        self ._emit (\n        \"create:done\",\n        strategy =\"contiguous\",\n        name =name ,\n        size_blocks =size_blocks ,\n        start =start ,\n        physical_blocks =indices ,\n        )\n\n\n\n\n    def delete (self ,name :str )->None :\n        self ._assert_file_exists (name )\n        self ._emit (\"delete:start\",strategy =\"contiguous\",name =name )\n\n        meta =self .file_table [name ]\n        start ,length =meta [\"start\"],meta [\"length\"]\n        indices =list (range (start ,start +length ))\n\n\n        self .fsm .free (indices )\n\n\n        del self .file_table [name ]\n\n        self ._emit (\"delete:done\",strategy =\"contiguous\",name =name ,released =indices )\n\n\n\n\n    def read (self ,name :str ,offset :int ,n_blocks :int ,access_mode :str =\"seq\")->List [bytes ]:\n        self ._assert_file_exists (name )\n        self ._assert_non_negative (offset )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_range_within_size (name ,offset ,n_blocks )\n\n        phys =self ._resolve_range (name ,offset ,n_blocks )\n        self ._emit (\n        \"read:start\",\n        strategy =\"contiguous\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =phys ,\n        )\n\n\n        data =[self .disk .read_block (i )or b\"\"for i in phys ]\n\n        self ._emit (\n        \"read:done\",\n        strategy =\"contiguous\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =phys ,\n        )\n        return data \n\n\n\n\n    def write (self ,name :str ,offset :int ,n_blocks :int ,data :Iterable [bytes ]|None =None )->None :\n        self ._assert_file_exists (name )\n        self ._assert_non_negative (offset )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_range_within_size (name ,offset ,n_blocks )\n\n        phys =self ._resolve_range (name ,offset ,n_blocks )\n        self ._emit (\n        \"write:start\",\n        strategy =\"contiguous\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =phys ,\n        )\n\n        payloads :List [bytes |None ]\n        if data is None :\n            payloads =[b\"\"for _ in range (n_blocks )]\n        else :\n            payloads =list (data )\n            if len (payloads )!=n_blocks :\n                raise ValueError (\"La cantidad de datos no coincide con n_blocks\")\n\n\n        self .disk .write_blocks (phys ,payloads )\n\n        self ._emit (\n        \"write:done\",\n        strategy =\"contiguous\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =phys ,\n        )\n\n\n\n\n    def _resolve_range (self ,name :str ,offset :int ,n_blocks :int )->List [int ]:\n        self ._assert_file_exists (name )\n        self ._assert_non_negative (offset )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_range_within_size (name ,offset ,n_blocks )\n\n        meta =self .file_table [name ]\n        start =meta [\"start\"]\n        return [start +i for i in range (offset ,offset +n_blocks )]\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\fs_strategies\\indexed.py": "\nfrom __future__ import annotations \nimport struct \nfrom typing import Iterable ,List ,Any ,Dict ,Optional ,Callable \n\n\nfrom ..core .filesystem_base import FilesystemBase ,DiskLike ,FreeSpaceManagerLike \n\n\n\n\nPOINTER_FORMAT_CHAR =\"q\"\nPOINTER_SIZE_BYTES =struct .calcsize (POINTER_FORMAT_CHAR )\n\n\nclass IndexedFS (FilesystemBase ):\n    \"\"\"\n    Estrategia de **asignación indexada (nivel único)**.\n\n    Metadata en self.file_table[name]:\n      {\n        \"size_blocks\": int,\n        \"index_block\": int,       # Bloque físico que contiene los punteros\n        # \"data_blocks\" NO se almacena aquí. Se lee del \"index_block\"\n        \"overhead_blocks\": 1      # 1 bloque para el índice\n      }\n\n    Lógica:\n    - `create`: Reserva 1 bloque para el índice + N bloques para datos.\n                Escribe la lista de punteros a datos en el bloque índice.\n    - `_resolve_range`: Lee el bloque índice y devuelve la porción solicitada\n                        de la tabla de punteros.\n    - `delete`: Libera el bloque índice Y todos los bloques de datos.\n    \"\"\"\n\n    def __init__ (\n    self ,\n    disk :DiskLike ,\n    free_space_manager :FreeSpaceManagerLike ,\n    *,\n    on_event :Optional [Callable [...,None ]]=None ,\n    )->None :\n        super ().__init__ (disk ,free_space_manager ,on_event =on_event )\n\n        self ._max_file_blocks =self .disk .block_size //POINTER_SIZE_BYTES \n\n\n\n\n\n    def _read_index_block (self ,index_block_idx :int ,size_blocks :int )->List [int ]:\n        \"\"\"\n        Lee el bloque índice y decodifica los punteros a bloques de datos.\n        \"\"\"\n        data =self .disk .read_block (index_block_idx )\n        if data is None :\n            raise IOError (f\"Corrupción: Bloque índice {index_block_idx } está vacío\")\n\n\n        format_string =f\"!{size_blocks }{POINTER_FORMAT_CHAR }\"\n\n        try :\n\n            pointers =struct .unpack (format_string ,data [:size_blocks *POINTER_SIZE_BYTES ])\n            return list (pointers )\n        except struct .error :\n            raise IOError (f\"Corrupción: No se pudo decodificar el bloque índice {index_block_idx }\")\n\n    def _write_index_block (self ,index_block_idx :int ,data_blocks :List [int ])->None :\n        \"\"\"\n        Codifica la lista de punteros y la escribe en el bloque índice.\n        \"\"\"\n\n        format_string =f\"!{len (data_blocks )}{POINTER_FORMAT_CHAR }\"\n\n        try :\n\n            packed_data =struct .pack (format_string ,*data_blocks )\n\n\n            if len (packed_data )<self .disk .block_size :\n                padding =b\"\\x00\"*(self .disk .block_size -len (packed_data ))\n                packed_data +=padding \n\n            self .disk .write_block (index_block_idx ,packed_data )\n        except struct .error as e :\n            raise IOError (f\"Error al empaquetar el bloque índice: {e }\")\n\n\n\n\n\n    def create (self ,name :str ,size_blocks :int )->None :\n        \"\"\"\n        Crea un archivo con un bloque índice que referencia 'size_blocks' bloques de datos.\n        \"\"\"\n        self ._assert_new_file (name )\n        self ._assert_positive_blocks (size_blocks )\n\n\n        if size_blocks >self ._max_file_blocks :\n            raise MemoryError (\n            f\"Archivo demasiado grande ({size_blocks } bloques). \"\n            f\"Solo caben {self ._max_file_blocks } punteros en un bloque índice \"\n            f\"de {self .disk .block_size } bytes.\"\n            )\n\n        self ._emit (\"create:start\",strategy =\"indexed\",name =name ,size_blocks =size_blocks )\n\n\n        total_blocks_needed =size_blocks +1 \n        try :\n            allocated_indices =self .fsm .allocate (total_blocks_needed ,contiguous =False )\n        except MemoryError :\n            raise MemoryError (f\"No hay espacio suficiente para {total_blocks_needed } bloques\")\n\n\n        index_block_idx =allocated_indices .pop (0 )\n        data_blocks_indices =allocated_indices \n\n\n        self .file_table [name ]={\n        \"size_blocks\":size_blocks ,\n        \"index_block\":index_block_idx ,\n        \"overhead_blocks\":1 \n        }\n\n\n        try :\n            self ._write_index_block (index_block_idx ,data_blocks_indices )\n        except (IOError ,struct .error )as e :\n\n            print (f\"Fallo al escribir el índice, revirtiendo creación: {e }\")\n            self .fsm .free (data_blocks_indices +[index_block_idx ])\n            del self .file_table [name ]\n            raise \n\n        self ._emit (\n        \"create:done\",\n        strategy =\"indexed\",\n        name =name ,\n        size_blocks =size_blocks ,\n        index_block =index_block_idx ,\n        data_blocks =data_blocks_indices \n        )\n\n    def delete (self ,name :str )->None :\n        \"\"\"\n        Elimina el archivo 'name', liberando su bloque índice y todos sus bloques de datos.\n        \"\"\"\n        self ._assert_file_exists (name )\n        meta =self .file_table [name ]\n\n        self ._emit (\"delete:start\",strategy =\"indexed\",name =name )\n\n        blocks_to_free =[]\n        try :\n\n            data_blocks =self ._read_index_block (meta [\"index_block\"],meta [\"size_blocks\"])\n            blocks_to_free .extend (data_blocks )\n        except IOError as e :\n\n            print (f\"Advertencia: Índice de '{name }' corrupto. Se liberará solo el bloque índice. Error: {e }\")\n\n\n        blocks_to_free .append (meta [\"index_block\"])\n\n\n        del self .file_table [name ]\n\n\n        try :\n            self .fsm .free (blocks_to_free )\n        except (ValueError ,IndexError )as e :\n            print (f\"Error al liberar bloques para '{name }': {e }\")\n\n        self ._emit (\"delete:done\",strategy =\"indexed\",name =name ,freed =blocks_to_free )\n\n    def _resolve_range (self ,name :str ,offset :int ,n_blocks :int )->List [int ]:\n        \"\"\"\n        Devuelve la lista de índices físicos para [offset, offset+n_blocks),\n        leyendo el bloque índice y devolviendo una sub-lista.\n        \"\"\"\n        self ._assert_file_exists (name )\n        meta =self .file_table [name ]\n\n\n        self ._assert_range_within_size (name ,offset ,n_blocks )\n\n\n        all_data_blocks =self ._read_index_block (meta [\"index_block\"],meta [\"size_blocks\"])\n\n\n        return all_data_blocks [offset :offset +n_blocks ]\n\n    def read (self ,name :str ,offset :int ,n_blocks :int ,access_mode :str =\"seq\")->List [bytes ]:\n        \"\"\"\n        Lee 'n_blocks' desde 'offset' usando el bloque índice.\n        \"\"\"\n        self ._assert_file_exists (name )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_non_negative (offset )\n\n\n        physical_indices =self ._resolve_range (name ,offset ,n_blocks )\n\n        self ._emit (\n        \"read:start\",\n        strategy =\"indexed\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =physical_indices ,\n        access_mode =access_mode \n        )\n\n\n        payloads =[]\n        for block_idx in physical_indices :\n            data =self .disk .read_block (block_idx )\n\n            payloads .append (b\"\"if data is None else data )\n\n        self ._emit (\"read:done\",strategy =\"indexed\",name =name )\n        return payloads \n\n    def write (self ,name :str ,offset :int ,n_blocks :int ,data :Iterable [bytes ]|None =None )->None :\n        \"\"\"\n        Escribe 'n_blocks' desde 'offset' consultando el índice.\n        \"\"\"\n        self ._assert_file_exists (name )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_non_negative (offset )\n\n\n        physical_indices =self ._resolve_range (name ,offset ,n_blocks )\n\n\n        data_list :List [bytes |None ]\n        if data is None :\n\n            data_list =[b\"\"]*n_blocks \n        else :\n            data_list =list (data )\n            if len (data_list )!=n_blocks :\n                raise ValueError (f\"Se esperaban {n_blocks } bloques, se recibieron {len (data_list )}\")\n\n        self ._emit (\n        \"write:start\",\n        strategy =\"indexed\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =physical_indices \n        )\n\n\n        for i in range (n_blocks ):\n            block_idx =physical_indices [i ]\n            payload =data_list [i ]\n\n\n            self .disk .write_block (block_idx ,payload )\n\n        self ._emit (\"write:done\",strategy =\"indexed\",name =name )", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\fs_strategies\\linked.py": "import struct \nfrom typing import List ,Dict ,Any ,Iterable ,Optional ,Callable \n\n\nfrom ..core .filesystem_base import FilesystemBase ,DiskLike ,FreeSpaceManagerLike \n\n\n\n\nEND_OF_FILE_MARKER =-1 \n\n\n\nPOINTER_FORMAT =\"!q\"\nPOINTER_SIZE_BYTES =struct .calcsize (POINTER_FORMAT )\n\n\nclass LinkedFS (FilesystemBase ):\n    \"\"\"\n    Implementación de un sistema de archivos con asignación enlazada (Linked Allocation).\n\n    Lógica:\n    - El directorio (self.file_table) almacena el bloque de inicio de cada archivo.\n    - Cada bloque en el disco utiliza sus primeros 'POINTER_SIZE_BYTES' bytes\n      para almacenar el índice del *siguiente* bloque.\n    - El último bloque de un archivo apunta a 'END_OF_FILE_MARKER'.\n    - El resto del bloque (block_size - POINTER_SIZE_BYTES) se usa para datos.\n    \"\"\"\n\n    def __init__ (\n    self ,\n    disk :DiskLike ,\n    free_space_manager :FreeSpaceManagerLike ,\n    *,\n    on_event :Optional [Callable [...,None ]]=None ,\n    )->None :\n        \"\"\"\n        Inicializa el FS. Valida que los bloques sean lo suficientemente grandes\n        para albergar, como mínimo, un puntero.\n        \"\"\"\n        super ().__init__ (disk ,free_space_manager ,on_event =on_event )\n\n\n        if self .disk .block_size <=POINTER_SIZE_BYTES :\n            raise ValueError (\n            f\"El tamaño de bloque ({self .disk .block_size }B) debe ser \"\n            f\"mayor que el tamaño del puntero ({POINTER_SIZE_BYTES }B)\"\n            )\n\n\n\n\n\n    def _read_pointer (self ,block_index :int )->int :\n        \"\"\"\n        Lee el bloque 'block_index' del disco y extrae el puntero\n        (los primeros bytes) del siguiente bloque.\n        \"\"\"\n        data =self .disk .read_block (block_index )\n        if data is None or len (data )<POINTER_SIZE_BYTES :\n\n\n            raise IOError (\n            f\"Error de E/S: Bloque {block_index } en la cadena está \"\n            f\"corrupto o vacío (no se pudo leer el puntero).\"\n            )\n\n\n        (next_block_index ,)=struct .unpack (POINTER_FORMAT ,data [:POINTER_SIZE_BYTES ])\n        return int (next_block_index )\n\n    def _write_pointer (self ,block_index :int ,next_block_index :int )->None :\n        \"\"\"\n        Escribe el puntero 'next_block_index' al inicio del bloque 'block_index'.\n        Preserva los datos de usuario existentes en ese bloque si los hay.\n        \"\"\"\n\n        pointer_bytes =struct .pack (POINTER_FORMAT ,next_block_index )\n\n\n        current_data =self .disk .read_block (block_index )\n\n        user_data =b\"\"\n        if current_data is not None and len (current_data )>POINTER_SIZE_BYTES :\n\n            user_data =current_data [POINTER_SIZE_BYTES :]\n\n\n        full_block_data =pointer_bytes +user_data \n\n\n\n        self .disk .write_block (block_index ,full_block_data )\n\n    def _get_all_blocks (self ,name :str )->List [int ]:\n        \"\"\"\n        Recorre la cadena completa del archivo 'name' y devuelve\n        la lista de todos sus bloques físicos. Usado por delete().\n        \"\"\"\n        self ._assert_file_exists (name )\n        meta =self .file_table [name ]\n\n        indices =[]\n        current_block_idx =meta [\"start_block\"]\n\n\n        for _ in range (meta [\"size_blocks\"]):\n            if current_block_idx ==END_OF_FILE_MARKER :\n                raise IOError (f\"Corrupción detectada: Fin de archivo prematuro para '{name }'\")\n\n            if current_block_idx in indices :\n                raise IOError (f\"Corrupción detectada: Bucle en la cadena de '{name }' en el bloque {current_block_idx }\")\n\n            indices .append (current_block_idx )\n\n            current_block_idx =self ._read_pointer (current_block_idx )\n\n        return indices \n\n\n\n\n\n    def create (self ,name :str ,size_blocks :int )->None :\n        \"\"\"\n        Crea un archivo 'name' de 'size_blocks', solicitando bloques\n        no contiguos al FSM y enlazándolos en el disco.\n        \"\"\"\n        self ._assert_new_file (name )\n        self ._assert_positive_blocks (size_blocks )\n\n\n\n        allocated_indices =self .fsm .allocate (size_blocks ,contiguous =False )\n\n\n        self .file_table [name ]={\n        \"size_blocks\":size_blocks ,\n        \"start_block\":allocated_indices [0 ],\n        }\n\n\n        for i in range (size_blocks -1 ):\n            current_idx =allocated_indices [i ]\n            next_idx =allocated_indices [i +1 ]\n\n            self ._write_pointer (current_idx ,next_idx )\n\n\n        last_idx =allocated_indices [-1 ]\n        self ._write_pointer (last_idx ,END_OF_FILE_MARKER )\n\n\n        self ._emit (\n        \"create\",\n        name =name ,\n        size_blocks =size_blocks ,\n        allocated =allocated_indices ,\n        )\n\n    def delete (self ,name :str )->None :\n        \"\"\"\n        Elimina el archivo 'name', recorriendo su cadena de bloques\n        para liberarlos todos en el FSM.\n        \"\"\"\n        self ._assert_file_exists (name )\n\n\n        try :\n            blocks_to_free =self ._get_all_blocks (name )\n        except IOError as e :\n            print (f\"Advertencia: No se pudo eliminar '{name }' limpiamente: {e }. \"\n            \"Se intentará liberar lo encontrado...\")\n\n            meta =self .file_table .get (name ,{})\n            start_block =meta .get (\"start_block\")\n            if isinstance (start_block ,int ):\n\n                indices =[]\n                curr =start_block \n                while curr !=END_OF_FILE_MARKER and curr not in indices and len (indices )<self .n_blocks :\n                    indices .append (curr )\n                    try :curr =self ._read_pointer (curr )\n                    except IOError :break \n                blocks_to_free =indices \n            else :\n                blocks_to_free =[]\n\n\n        del self .file_table [name ]\n\n\n        if blocks_to_free :\n            try :\n                self .fsm .free (blocks_to_free )\n            except (ValueError ,IndexError )as e :\n\n                print (f\"Error al liberar bloques para '{name }': {e }\")\n\n\n        self ._emit (\"delete\",name =name ,freed =blocks_to_free )\n\n    def _resolve_range (self ,name :str ,offset :int ,n_blocks :int )->List [int ]:\n        \"\"\"\n        Devuelve la lista de bloques físicos correspondientes al rango\n        lógico [offset, offset + n_blocks) del archivo 'name'.\n        \n        Esta es la operación costosa en \"Linked\", ya que requiere 'offset'\n        lecturas de punteros para llegar al inicio del rango.\n        \"\"\"\n        self ._assert_file_exists (name )\n        meta =self .file_table [name ]\n\n\n        self ._assert_range_within_size (name ,offset ,n_blocks )\n\n        current_block_idx =meta [\"start_block\"]\n\n\n\n        for _ in range (offset ):\n            current_block_idx =self ._read_pointer (current_block_idx )\n            if current_block_idx ==END_OF_FILE_MARKER :\n\n                raise IndexError (\n                f\"Corrupción: EOF alcanzado prematuramente \"\n                f\"mientras se buscaba el offset {offset } en '{name }'\"\n                )\n\n\n        physical_indices =[]\n        for i in range (n_blocks ):\n            if current_block_idx ==END_OF_FILE_MARKER :\n                 raise IndexError (\n                 f\"Corrupción: EOF alcanzado prematuramente \"\n                 f\"mientras se leían {n_blocks } bloques en '{name }'\"\n                 )\n\n            physical_indices .append (current_block_idx )\n\n\n            if i <(n_blocks -1 ):\n                current_block_idx =self ._read_pointer (current_block_idx )\n\n        return physical_indices \n\n    def read (\n    self ,name :str ,offset :int ,n_blocks :int ,access_mode :str =\"seq\"\n    )->List [bytes ]:\n        \"\"\"\n        Lee 'n_blocks' lógicos desde 'offset' del archivo 'name'.\n        Devuelve solo los datos de *usuario* (sin los punteros).\n        \"\"\"\n        self ._assert_file_exists (name )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_non_negative (offset )\n\n\n        physical_indices =self ._resolve_range (name ,offset ,n_blocks )\n\n\n        self ._emit (\n        \"read\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =physical_indices ,\n        access_mode =access_mode \n        )\n\n\n        payloads =[]\n        for block_idx in physical_indices :\n            full_data =self .disk .read_block (block_idx )\n\n            if full_data is None :\n\n\n                payloads .append (b\"\")\n            else :\n\n                user_data =full_data [POINTER_SIZE_BYTES :]\n                payloads .append (user_data )\n\n        return payloads \n\n    def write (\n    self ,\n    name :str ,\n    offset :int ,\n    n_blocks :int ,\n    data :Optional [Iterable [bytes ]]=None ,\n    )->None :\n        \"\"\"\n        Escribe 'n_blocks' lógicos desde 'offset' en 'name'.\n        Esto sobrescribe datos de usuario, pero *preserva* los punteros.\n        Esta política no soporta crecimiento de archivo.\n        \"\"\"\n        self ._assert_file_exists (name )\n        self ._assert_positive_blocks (n_blocks )\n        self ._assert_non_negative (offset )\n\n\n        physical_indices =self ._resolve_range (name ,offset ,n_blocks )\n\n\n        data_list :List [bytes ]\n        if data is None :\n\n            data_list =[b\"\"]*n_blocks \n        else :\n            data_list =list (data )\n            if len (data_list )!=n_blocks :\n                raise ValueError (\n                f\"Se esperaban {n_blocks } bloques de datos, \"\n                f\"pero se recibieron {len (data_list )}\"\n                )\n\n\n        self ._emit (\n        \"write\",\n        name =name ,\n        offset =offset ,\n        n_blocks =n_blocks ,\n        physical =physical_indices \n        )\n\n\n        user_data_max_size =self .disk .block_size -POINTER_SIZE_BYTES \n\n        for i in range (n_blocks ):\n            block_idx =physical_indices [i ]\n            user_payload =data_list [i ]\n\n\n            if len (user_payload )>user_data_max_size :\n                raise ValueError (\n                f\"Payload del bloque {i } ({len (user_payload )}B) excede \"\n                f\"el espacio de usuario disponible ({user_data_max_size }B)\"\n                )\n\n\n            current_pointer =self ._read_pointer (block_idx )\n            pointer_bytes =struct .pack (POINTER_FORMAT ,current_pointer )\n\n\n            full_block_data =pointer_bytes +user_payload \n\n\n            self .disk .write_block (block_idx ,full_block_data )", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\sim\\metrics.py": "\nfrom __future__ import annotations \nfrom typing import Dict ,Any ,List \nimport json \nimport csv \nimport statistics \nimport time \n\n\n\n\n\ndef summarize (results :List [Dict [str ,Any ]])->Dict [str ,float ]:\n    \"\"\"\n    Calcula promedios básicos de rendimiento (versión resumida).\n    \"\"\"\n    if not results :\n        return {\n        \"avg_access_time_ms\":0.0 ,\n        \"space_usage_pct\":0.0 ,\n        \"fragmentation_internal_pct\":0.0 ,\n        \"fragmentation_external_pct\":0.0 ,\n        }\n\n    n =len (results )\n    avg_access_time =sum (r .get (\"access_time_ms\",0 )for r in results )/n \n    avg_usage =sum ((r .get (\"space_used\",0 )/max (r .get (\"space_total\",1 ),1 ))*100 for r in results )/n \n    avg_external_frag =sum (r .get (\"external_frag\",0 )*100 for r in results )/n \n\n    return {\n    \"avg_access_time_ms\":round (avg_access_time ,3 ),\n    \"space_usage_pct\":round (avg_usage ,2 ),\n    \"fragmentation_internal_pct\":0.0 ,\n    \"fragmentation_external_pct\":round (avg_external_frag ,2 ),\n    }\n\n\n\n\n\n\ndef full_metrics_summary (results :List [Dict [str ,Any ]])->Dict [str ,float ]:\n    \"\"\"\n    Calcula métricas completas de rendimiento según las especificaciones oficiales:\n      - Tiempo promedio de acceso\n      - Uso de espacio\n      - Fragmentación interna y externa\n      - Throughput (ops/seg)\n      - Hit/Miss ratio\n      - Uso de CPU\n      - Fairness (equidad)\n    \"\"\"\n\n    if not results :\n        return {\n        \"avg_access_time_ms\":0.0 ,\n        \"space_usage_pct\":0.0 ,\n        \"fragmentation_internal_pct\":0.0 ,\n        \"fragmentation_external_pct\":0.0 ,\n        \"throughput_ops_per_sec\":0.0 ,\n        \"hit_miss_ratio\":0.0 ,\n        \"cpu_usage_pct\":0.0 ,\n        \"fairness_index\":0.0 ,\n        }\n\n    n =len (results )\n\n\n    avg_access_time =sum (r .get (\"access_time_ms\",0 )for r in results )/n \n    total_time_s =sum (r .get (\"elapsed_time_s\",0 )for r in results )\n    throughput =n /total_time_s if total_time_s >0 else 0.0 \n\n\n    avg_usage =sum ((r .get (\"space_used\",0 )/max (r .get (\"space_total\",1 ),1 ))*100 for r in results )/n \n    avg_external_frag =sum (r .get (\"external_frag\",0 )*100 for r in results )/n \n    avg_internal_frag =sum (r .get (\"internal_frag\",0 )*100 for r in results )/n \n\n\n    total_hits =sum (r .get (\"hits\",0 )for r in results )\n    total_misses =sum (r .get (\"misses\",0 )for r in results )\n    hit_miss_ratio =(total_hits /(total_hits +total_misses ))*100 if (total_hits +total_misses )>0 else 0.0 \n\n\n    cpu_time =sum (r .get (\"cpu_time\",0.0 )for r in results )\n    total_elapsed =total_time_s if total_time_s >0 else 1.0 \n    cpu_usage_pct =(cpu_time /total_elapsed )*100 \n\n\n    access_times =[r .get (\"access_time_ms\",0 )for r in results if \"access_time_ms\"in r ]\n    fairness_index =0.0 \n    if len (access_times )>1 :\n        fairness_index =statistics .pstdev (access_times )/(sum (access_times )/len (access_times ))*100 \n\n    return {\n    \"avg_access_time_ms\":round (avg_access_time ,3 ),\n    \"space_usage_pct\":round (avg_usage ,2 ),\n    \"fragmentation_internal_pct\":round (avg_internal_frag ,2 ),\n    \"fragmentation_external_pct\":round (avg_external_frag ,2 ),\n    \"throughput_ops_per_sec\":round (throughput ,3 ),\n    \"hit_miss_ratio\":round (hit_miss_ratio ,2 ),\n    \"cpu_usage_pct\":round (cpu_usage_pct ,2 ),\n    \"fairness_index\":round (fairness_index ,2 ),\n    }\n\n\n\n\n\n\nclass Metrics :\n    def __init__ (self ,disk ,fsm ,fs ):\n        self .disk =disk \n        self .fsm =fsm \n        self .fs =fs \n        self .start_time =time .perf_counter ()\n        self .start_cpu =time .process_time ()\n\n    def compute (self )->Dict [str ,float ]:\n        \"\"\"Calcula métricas actuales del sistema.\"\"\"\n        total_blocks =self .fsm .n_blocks \n        used_blocks =self .fsm .used_count ()\n        free_blocks =self .fsm .free_count ()\n\n        external_frag =self .fsm .external_fragmentation_ratio ()*100 \n        internal_frag =0.0 \n\n        elapsed =time .perf_counter ()-self .start_time \n        cpu_time =time .process_time ()-self .start_cpu \n        cpu_usage_pct =(cpu_time /elapsed )*100 if elapsed >0 else 0.0 \n\n        return {\n        \"total_blocks\":total_blocks ,\n        \"used_blocks\":used_blocks ,\n        \"free_blocks\":free_blocks ,\n        \"space_usage_pct\":round ((used_blocks /total_blocks )*100 ,2 ),\n        \"fragmentation_external_pct\":round (external_frag ,2 ),\n        \"fragmentation_internal_pct\":round (internal_frag ,2 ),\n        \"files_stored\":len (self .fs .file_table ),\n        \"cpu_usage_pct\":round (cpu_usage_pct ,2 ),\n        }\n\n    def print_summary (self ):\n        m =self .compute ()\n        print (\"\\n===== MÉTRICAS DEL SISTEMA =====\")\n        for k ,v in m .items ():\n            print (f\"{k }: {v }\")\n\n    def export_json (self ,path :str =\"metrics.json\"):\n        with open (path ,\"w\",encoding =\"utf-8\")as f :\n            json .dump (self .compute (),f ,indent =4 )\n        print (f\"Métricas exportadas a {path }\")\n\n    def export_csv (self ,path :str =\"metrics.csv\"):\n        m =self .compute ()\n        with open (path ,\"w\",newline =\"\",encoding =\"utf-8\")as f :\n            writer =csv .writer (f )\n            writer .writerow ([\"Métrica\",\"Valor\"])\n            for k ,v in m .items ():\n                writer .writerow ([k ,v ])\n        print (f\"Métricas exportadas a {path }\")\n\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\sim\\runner.py": "\nfrom __future__ import annotations \nimport csv ,json ,time \nfrom pathlib import Path \nfrom typing import Dict ,Any ,List ,Callable ,Optional ,Tuple \n\nfrom ..core .disk import Disk \nfrom ..core .free_space import FreeSpaceManager \nfrom ..fs_strategies .contiguous import ContiguousFS \nfrom ..fs_strategies .linked import LinkedFS \nfrom ..fs_strategies .indexed import IndexedFS \nfrom .scenario_definitions import DEFAULTS ,load_from_json \nfrom .workload_generators import generate_workload \nfrom .metrics import summarize ,full_metrics_summary \n\nSTRATEGIES ={\n\"contiguous\":ContiguousFS ,\n\"linked\":LinkedFS ,\n\"indexed\":IndexedFS ,\n}\n\n\ndef build_config (\nscenario :str |None ,\nscenarios_path :str |None ,\noverrides :Dict [str ,Any ],\n)->Dict [str ,Any ]:\n    cfg :Dict [str ,Any ]={}\n    if scenario :\n        cfgs ={**DEFAULTS ,**(load_from_json (scenarios_path )if scenarios_path else {})}\n        if scenario not in cfgs :\n            raise KeyError (f\"Escenario '{scenario }' no existe\")\n        cfg .update (cfgs [scenario ])\n    cfg .update (overrides or {})\n    return cfg \n\n\ndef _make_event_handler (collector :Dict [str ,Any ])->Callable [...,None ]:\n    def on_event (event_type :str ,**payload :Any )->None :\n        collector [\"last_event\"]=(event_type ,payload )\n        phys =payload .get (\"physical\")\n        if isinstance (phys ,list )and phys :\n            seeks =0 \n            for i in range (len (phys )-1 ):\n                if phys [i +1 ]!=phys [i ]+1 :\n                    seeks +=1 \n            collector [\"seeks\"]=collector .get (\"seeks\",0 )+seeks \n        nb =payload .get (\"n_blocks\")\n        if isinstance (nb ,int )and nb >0 :\n            collector [\"blocks_touched\"]=collector .get (\"blocks_touched\",0 )+nb \n    return on_event \n\n\ndef _snapshot_state (fsm :FreeSpaceManager )->Dict [str ,float ]:\n    total =fsm .n_blocks \n    used =fsm .used_count ()\n    usage_pct =(used /total )*100 if total >0 else 0.0 \n    ext_frag =fsm .external_fragmentation_ratio ()\n    return {\n    \"space_used\":float (used ),\n    \"space_total\":float (total ),\n    \"space_usage_pct\":float (usage_pct ),\n    \"external_frag\":float (ext_frag ),\n    \"internal_frag\":0.0 ,\n    }\n\n\ndef run_simulation (\nstrategy_name :str ,\nscenario :str |None ,\nscenarios_path :str |None ,\nseed :int |None ,\noverrides :Dict [str ,Any ],\nout :str |None =None ,\non_bitmap_update :Optional [Callable [[str ,List [int ]],None ]]=None ,\nui_slowdown_ms :Optional [int ]=None ,\n\nuser_files :Optional [List [Dict [str ,Any ]]]=None ,\nrespect_user_files_only :bool =False ,\n\n)->Tuple [Dict [str ,Any ],Dict [str ,List [int ]]]:\n    \"\"\"\n    Ejecuta la simulación y devuelve:\n      - summaries: dict por estrategia con métricas agregadas y, además:\n          * files_manifest: lista de archivos con estado final y contadores\n          * op_traces: lista de trazas por operación (para gráficos de UI)\n      - final_bitmaps: bitmap final por estrategia (para UI)\n    \"\"\"\n    if strategy_name not in STRATEGIES and strategy_name !=\"all\":\n        raise KeyError (f\"Estrategia inválida: {strategy_name }\")\n\n    cfg =build_config (scenario ,scenarios_path ,overrides )\n\n\n    ops =generate_workload (\n    cfg ,\n    seed =seed ,\n    user_files =user_files ,\n    respect_user_files_only =respect_user_files_only ,\n    )\n\n    strategies =list (STRATEGIES .keys ())if strategy_name ==\"all\"else [strategy_name ]\n    summaries :Dict [str ,Dict [str ,Any ]]={}\n    final_bitmaps :Dict [str ,List [int ]]={}\n\n    sleep_duration_s =0.0 \n    if ui_slowdown_ms and ui_slowdown_ms >0 :\n        sleep_duration_s =ui_slowdown_ms /1000.0 \n\n    for s in strategies :\n        disk_size =cfg .get (\"disk_size\",50000 )\n        block_size =cfg .get (\"block_size\",4096 )\n\n\n        max_blocks_for_ui =50000 \n        if disk_size >max_blocks_for_ui :\n            disk_size =max_blocks_for_ui \n\n        disk =Disk (\n        n_blocks =disk_size ,\n        block_size =block_size ,\n        prefill =None ,\n        )\n\n        fsm_callback =None \n        if on_bitmap_update :\n            def create_callback (strategy_key :str ):\n                return lambda bitmap :on_bitmap_update (strategy_key ,bitmap )\n            fsm_callback =create_callback (s )\n\n        fsm =FreeSpaceManager (\n        disk .n_blocks ,\n        on_bitmap_update =fsm_callback \n        )\n\n        results :List [Dict [str ,Any ]]=[]\n        event_acc :Dict [str ,Any ]={}\n        on_event =_make_event_handler (event_acc )\n        fs_class =STRATEGIES [s ]\n        fs =fs_class (disk ,fsm ,on_event =on_event )\n\n\n\n        files_manifest_map :Dict [str ,Dict [str ,Any ]]={}\n\n        op_traces :List [Dict [str ,Any ]]=[]\n\n\n        sim_start_wall =time .perf_counter ()\n        sim_start_cpu =time .process_time ()\n\n        for op_idx ,op in enumerate (ops ):\n            event_acc .clear ()\n            op_name =op .get (\"op\")\n            t0_wall =time .perf_counter ()\n            t0_cpu =time .process_time ()\n            hit ,miss =1 ,0 \n\n\n\n            if op_name ==\"create\":\n                fname =op [\"name\"]\n                fsize =int (op .get (\"size_blocks\",0 )or 0 )\n                if fsize <=0 :\n\n                    fsize =1 \n                if fname not in files_manifest_map :\n                    files_manifest_map [fname ]={\n                    \"name\":fname ,\n                    \"size_blocks\":fsize ,\n                    \"created_at\":op_idx ,\n                    \"deleted_at\":None ,\n                    \"alive\":True ,\n                    \"read_ops\":0 ,\n                    \"write_ops\":0 ,\n                    }\n                else :\n\n                    rec =files_manifest_map [fname ]\n                    rec [\"size_blocks\"]=fsize \n                    rec [\"created_at\"]=op_idx \n                    rec [\"deleted_at\"]=None \n                    rec [\"alive\"]=True \n\n\n            elif op_name ==\"read\":\n                fname =op .get (\"name\")\n                if fname in files_manifest_map :\n                    files_manifest_map [fname ][\"read_ops\"]+=1 \n            elif op_name ==\"write\":\n                fname =op .get (\"name\")\n                if fname in files_manifest_map :\n                    files_manifest_map [fname ][\"write_ops\"]+=1 \n\n\n            elif op_name ==\"delete\":\n                fname =op .get (\"name\")\n                if fname in files_manifest_map and files_manifest_map [fname ].get (\"deleted_at\")is None :\n                    files_manifest_map [fname ][\"deleted_at\"]=op_idx \n                    files_manifest_map [fname ][\"alive\"]=False \n\n\n            try :\n                if op_name ==\"create\":\n                    fs .create (op [\"name\"],op [\"size_blocks\"])\n                elif op_name ==\"delete\":\n                    fs .delete (op [\"name\"])\n                elif op_name ==\"read\":\n                    fs .read (op [\"name\"],op [\"offset\"],op [\"n_blocks\"],op .get (\"access_mode\",\"seq\"))\n                elif op_name ==\"write\":\n                    fs .write (op [\"name\"],op [\"offset\"],op [\"n_blocks\"],None )\n                else :\n                    hit ,miss =0 ,1 \n            except Exception :\n                hit ,miss =0 ,1 \n\n            op_elapsed_ms =(time .perf_counter ()-t0_wall )*1000.0 \n            op_cpu_s =(time .process_time ()-t0_cpu )\n            snap =_snapshot_state (fsm )\n            t_wall_since_start =time .perf_counter ()-sim_start_wall \n\n            if sleep_duration_s >0 :\n                time .sleep (sleep_duration_s )\n\n\n            result :Dict [str ,Any ]={\n            \"strategy\":s ,\"operation\":op_name ,\n            \"access_time_ms\":float (op_elapsed_ms ),\n            \"elapsed_time_s\":float (op_elapsed_ms /1000.0 ),\n            \"cpu_time\":float (op_cpu_s ),\"hits\":hit ,\"misses\":miss ,\n            \"seeks_est\":int (event_acc .get (\"seeks\",0 )),\n            \"blocks_touched\":int (event_acc .get (\"blocks_touched\",0 )),\n            \"space_used\":snap [\"space_used\"],\n            \"space_total\":snap [\"space_total\"],\n            \"external_frag\":snap [\"external_frag\"],\n            \"internal_frag\":snap [\"internal_frag\"],\n            }\n            results .append (result )\n\n\n            trace_item ={\n            \"op_index\":op_idx ,\n            \"operation\":op_name ,\n            \"name\":op .get (\"name\"),\n            \"size_blocks\":op .get (\"size_blocks\",0 ),\n            \"offset\":op .get (\"offset\",0 ),\n            \"n_blocks\":op .get (\"n_blocks\",0 ),\n            \"access_mode\":op .get (\"access_mode\",\"seq\"),\n            \"access_time_ms\":float (op_elapsed_ms ),\n            \"t_wall_from_start_s\":float (t_wall_since_start ),\n            \"external_frag_pct\":float (snap [\"external_frag\"]*100.0 ),\n            \"space_usage_pct\":float (snap [\"space_usage_pct\"]),\n            \"seeks_est\":int (event_acc .get (\"seeks\",0 )),\n            \"blocks_touched\":int (event_acc .get (\"blocks_touched\",0 )),\n            }\n            op_traces .append (trace_item )\n\n\n\n        total_elapsed_s =time .perf_counter ()-sim_start_wall \n        total_cpu_s =time .process_time ()-sim_start_cpu \n        results .append ({\n        \"strategy\":s ,\"operation\":\"TOTAL\",\n        \"access_time_ms\":total_elapsed_s *1000.0 /max (1 ,(len (results )or 1 )),\n        \"elapsed_time_s\":total_elapsed_s ,\"cpu_time\":total_cpu_s ,\n        \"hits\":sum (r [\"hits\"]for r in results if r .get (\"operation\")!=\"TOTAL\"),\n        \"misses\":sum (r [\"misses\"]for r in results if r .get (\"operation\")!=\"TOTAL\"),\n        \"seeks_est\":sum (r [\"seeks_est\"]for r in results if r .get (\"operation\")!=\"TOTAL\"),\n        \"blocks_touched\":sum (r [\"blocks_touched\"]for r in results if r .get (\"operation\")!=\"TOTAL\"),\n        **_snapshot_state (fsm ),\n        })\n\n\n        for rec in files_manifest_map .values ():\n            rec [\"alive\"]=rec .get (\"deleted_at\")is None \n\n\n        summary_ext =full_metrics_summary (results )\n        summary_basic =summarize (results )\n        summary_ext [\"elapsed_ms_total\"]=round (total_elapsed_s *1000.0 ,3 )\n        summary_ext [\"cpu_time_total_s\"]=round (total_cpu_s ,6 )\n        summary_ext [\"ops_count\"]=sum (1 for r in results if r .get (\"operation\")not in (\"TOTAL\",None ))\n        summary_ext [\"seeks_total_est\"]=int (sum (r [\"seeks_est\"]for r in results if r .get (\"operation\")!=\"TOTAL\"))\n        summary_ext [\"_scenario\"]=scenario or \"overrides-only\"\n        summary_ext [\"_seed\"]=seed \n\n\n        files_manifest_list =sorted (files_manifest_map .values (),key =lambda r :r [\"name\"])\n        summary_ext [\"files_manifest\"]=files_manifest_list \n        summary_ext [\"op_traces\"]=op_traces \n\n\n        summaries [s ]={**summary_ext ,\"_basic\":summary_basic }\n        final_bitmaps [s ]=fsm .snapshot_bitmap ()\n\n\n    if out :\n        p =Path (out )\n        p .parent .mkdir (parents =True ,exist_ok =True )\n        if p .suffix .lower ()==\".csv\":\n            key_order =[\n            \"avg_access_time_ms\",\"space_usage_pct\",\"fragmentation_internal_pct\",\n            \"fragmentation_external_pct\",\"throughput_ops_per_sec\",\"hit_miss_ratio\",\n            \"cpu_usage_pct\",\"fairness_index\",\"elapsed_ms_total\",\n            \"cpu_time_total_s\",\"ops_count\",\"seeks_total_est\",\n            ]\n            with p .open (\"w\",newline =\"\",encoding =\"utf-8\")as f :\n                writer =csv .writer (f )\n                writer .writerow ([\"strategy\"]+key_order )\n                for strat ,vals in summaries .items ():\n                    row =[strat ]+[vals .get (k ,\"\")for k in key_order ]\n                    writer .writerow (row )\n        else :\n            with p .open (\"w\",encoding =\"utf-8\")as f :\n                json .dump (summaries ,f ,indent =2 )\n\n    return summaries ,final_bitmaps \n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\sim\\scenario_definitions.py": "\nfrom __future__ import annotations \nimport json \nfrom pathlib import Path \nfrom typing import Dict ,Any ,Tuple \n\n\n\n\n\nDEFAULTS :Dict [str ,Dict [str ,Any ]]={\n\"mix-small-large\":{\n\"description\":\"Mezcla de archivos pequeños y grandes, 60% secuencial, 40% aleatorio\",\n\"disk_size\":50000 ,\n\"block_size\":4096 ,\n\"n_files_small\":200 ,\n\"file_small_range\":[1 ,16 ],\n\"n_files_large\":30 ,\n\"file_large_range\":[256 ,2048 ],\n\"access_pattern\":{\"seq\":0.6 ,\"rand\":0.4 },\n\"delete_rate\":0.1 ,\n\"ops\":1000 ,\n},\n\"seq-vs-rand\":{\n\"description\":\"Comparativa de acceso 90% secuencial vs 90% aleatorio\",\n\"disk_size\":40000 ,\n\"block_size\":4096 ,\n\"n_files_small\":150 ,\n\"file_small_range\":[1 ,32 ],\n\"n_files_large\":20 ,\n\"file_large_range\":[128 ,1024 ],\n\"access_pattern\":{\"seq\":0.9 ,\"rand\":0.1 },\n\"delete_rate\":0.05 ,\n\"ops\":800 ,\n},\n\"frag-intensive\":{\n\"description\":\"Creación/borrado intensivo para inducir fragmentación\",\n\"disk_size\":60000 ,\n\"block_size\":4096 ,\n\"n_files_small\":250 ,\n\"file_small_range\":[1 ,8 ],\n\"n_files_large\":10 ,\n\"file_large_range\":[512 ,1024 ],\n\"access_pattern\":{\"seq\":0.5 ,\"rand\":0.5 },\n\"delete_rate\":0.4 ,\n\"ops\":1500 ,\n},\n}\n\n\n_REQUIRED_KEYS ={\n\"description\":str ,\n\"disk_size\":int ,\n\"block_size\":int ,\n\"n_files_small\":int ,\n\"file_small_range\":(list ,tuple ),\n\"n_files_large\":int ,\n\"file_large_range\":(list ,tuple ),\n\"access_pattern\":dict ,\n\"delete_rate\":(int ,float ),\n\"ops\":int ,\n}\n\n\n\n\n\ndef load_from_json (path :str |Path )->Dict [str ,Dict [str ,Any ]]:\n    \"\"\"\n    Carga escenarios desde un JSON opcional. El archivo debe mapear:\n      { \"<scenario_name>\": {<config>}, ... }\n    Si el archivo no existe, retorna {}.\n    \"\"\"\n    p =Path (path )\n    if not p .exists ():\n        return {}\n    with p .open (\"r\",encoding =\"utf-8\")as f :\n        data =json .load (f )\n    if not isinstance (data ,dict ):\n        raise ValueError (\"El JSON de escenarios debe ser un objeto {nombre: config}.\")\n\n    return data \n\n\n\n\n\ndef _as_range_pair (value :Any ,field :str )->Tuple [int ,int ]:\n    \"\"\"\n    Normaliza un rango ingresado como [min, max] o (min, max) a (int, int).\n    Valida que 1 <= min <= max.\n    \"\"\"\n    if not isinstance (value ,(list ,tuple ))or len (value )!=2 :\n        raise ValueError (f\"{field } debe ser una lista/tupla [min, max].\")\n    a ,b =value \n    if not (isinstance (a ,int )and isinstance (b ,int )):\n        raise ValueError (f\"{field } debe contener enteros.\")\n    if a <1 or b <1 or a >b :\n        raise ValueError (f\"{field } inválido: se requiere 1 <= min <= max (recibido {value }).\")\n    return int (a ),int (b )\n\ndef _normalize_access_pattern (p :Dict [str ,Any ])->Dict [str ,float ]:\n    \"\"\"\n    Normaliza access_pattern para que contenga claves 'seq' y 'rand' y sume 1.0.\n    Si faltan, se asigna 0.0. Si suma 0, se usa (1.0, 0.0) por defecto.\n    \"\"\"\n    seq =float (p .get (\"seq\",0.0 ))\n    rand =float (p .get (\"rand\",0.0 ))\n    total =seq +rand \n    if total <=0.0 :\n\n        return {\"seq\":1.0 ,\"rand\":0.0 }\n    return {\"seq\":seq /total ,\"rand\":rand /total }\n\ndef _validate_schema (name :str ,cfg :Dict [str ,Any ])->None :\n    \"\"\"\n    Valida tipos y rangos básicos. Lanza ValueError con mensajes claros.\n    \"\"\"\n    for k ,typ in _REQUIRED_KEYS .items ():\n        if k not in cfg :\n            raise ValueError (f\"[{name }] Falta clave requerida: '{k }'\")\n        if not isinstance (cfg [k ],typ ):\n            raise ValueError (f\"[{name }] Tipo inválido para '{k }': esperado {typ }, recibido {type (cfg [k ])}\")\n\n    if cfg [\"disk_size\"]<=0 :\n        raise ValueError (f\"[{name }] 'disk_size' debe ser > 0\")\n    if cfg [\"block_size\"]<=0 :\n        raise ValueError (f\"[{name }] 'block_size' debe ser > 0\")\n    if cfg [\"n_files_small\"]<0 or cfg [\"n_files_large\"]<0 :\n        raise ValueError (f\"[{name }] 'n_files_small' y 'n_files_large' deben ser >= 0\")\n    if cfg [\"ops\"]<=0 :\n        raise ValueError (f\"[{name }] 'ops' debe ser > 0\")\n\n\n    _as_range_pair (cfg [\"file_small_range\"],\"file_small_range\")\n    _as_range_pair (cfg [\"file_large_range\"],\"file_large_range\")\n\n\n    dr =float (cfg [\"delete_rate\"])\n    if dr <0.0 or dr >1.0 :\n        raise ValueError (f\"[{name }] 'delete_rate' debe estar en [0, 1] (recibido {dr }).\")\n\n\n    if not isinstance (cfg [\"access_pattern\"],dict ):\n        raise ValueError (f\"[{name }] 'access_pattern' debe ser dict con claves 'seq'/'rand'.\")\n\ndef _normalize_config (cfg :Dict [str ,Any ])->Dict [str ,Any ]:\n    \"\"\"\n    Retorna una copia normalizada del config:\n      - Rango de tamaños como tuplas (min,max)\n      - access_pattern normalizado a prob distribucional\n    \"\"\"\n    norm =dict (cfg )\n    norm [\"file_small_range\"]=_as_range_pair (cfg [\"file_small_range\"],\"file_small_range\")\n    norm [\"file_large_range\"]=_as_range_pair (cfg [\"file_large_range\"],\"file_large_range\")\n    norm [\"access_pattern\"]=_normalize_access_pattern (cfg [\"access_pattern\"])\n    return norm \n\n\n\n\n\ndef available_scenarios (extra_path :str |Path |None =None )->Dict [str ,str ]:\n    \"\"\"\n    Devuelve {nombre: descripción} de escenarios disponibles,\n    combinando DEFAULTS con los definidos en extra_path (si existe).\n    \"\"\"\n    combined :Dict [str ,Dict [str ,Any ]]=dict (DEFAULTS )\n    if extra_path :\n        combined .update (load_from_json (extra_path ))\n    return {k :v .get (\"description\",\"\")for k ,v in combined .items ()}\n\ndef get_config (\nscenario :str |None ,\nscenarios_path :str |Path |None =None ,\noverrides :Dict [str ,Any ]|None =None ,\n)->Dict [str ,Any ]:\n    \"\"\"\n    Resuelve la configuración final a usar por el runner:\n      1) Parte del escenario elegido desde DEFAULTS + JSON externo (si hay).\n      2) Aplica overrides (si vienen).\n      3) Valida y normaliza (rangos, pesos, límites).\n    Lanza KeyError si no existe el escenario indicado.\n    Lanza ValueError si hay inconsistencias de esquema o valores.\n    \"\"\"\n    combined :Dict [str ,Dict [str ,Any ]]=dict (DEFAULTS )\n    if scenarios_path :\n        combined .update (load_from_json (scenarios_path ))\n\n    cfg :Dict [str ,Any ]={}\n    if scenario :\n        if scenario not in combined :\n            raise KeyError (f\"Escenario '{scenario }' no existe\")\n        cfg .update (combined [scenario ])\n\n    if overrides :\n        cfg .update (overrides )\n\n    if not cfg :\n        raise ValueError (\"No se proporcionó escenario ni overrides con configuración.\")\n\n\n    _validate_schema (scenario or \"<overrides>\",cfg )\n    cfg =_normalize_config (cfg )\n    return cfg \n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\sim\\workload_generators.py": "\nfrom __future__ import annotations \nimport random \nfrom typing import Dict ,Any ,List ,Tuple ,Optional ,Set \n\n\n\n\n\ndef _rand_size (rng :random .Random ,rng_pair :Tuple [int ,int ])->int :\n    \"\"\"Devuelve un tamaño en bloques dentro del rango [min, max].\"\"\"\n    lo ,hi =rng_pair \n    return rng .randint (lo ,hi )\n\ndef _choose_access_mode (rng :random .Random ,seq_prob :float )->str :\n    \"\"\"Elige 'seq' o 'rand' según probabilidad de acceso secuencial.\"\"\"\n    return \"seq\"if rng .random ()<seq_prob else \"rand\"\n\ndef _ensure_min_ops_weights (delete_rate :float )->List [float ]:\n    \"\"\"\n    Devuelve pesos [create, delete, read, write] coherentes.\n    - Aumenta 'delete' en función de delete_rate para inducir fragmentación cuando se solicita.\n    - Mantiene un equilibrio razonable para que haya lecturas/escrituras útiles.\n    \"\"\"\n\n    w_create =0.25 \n\n    w_delete =min (0.1 +0.8 *delete_rate ,0.45 )\n\n    remaining =max (0.0 ,1.0 -(w_create +w_delete ))\n    w_read =remaining *0.5 \n    w_write =remaining *0.5 \n    return [w_create ,w_delete ,w_read ,w_write ]\n\ndef _new_name (kind :str ,idx :int )->str :\n    \"\"\"Construye un nombre único determinista.\"\"\"\n    return f\"{kind }_{idx :06d}\"\n\ndef _next_unique_name (kind :str ,counter :int ,existing :Set [str ])->Tuple [str ,int ]:\n    \"\"\"\n    Genera el siguiente nombre único (sin colisionar con 'existing')\n    y devuelve (name, next_counter).\n    \"\"\"\n    while True :\n        name =_new_name (kind ,counter )\n        counter +=1 \n        if name not in existing :\n            return name ,counter \n\ndef _pick_existing (rng :random .Random ,names :List [str ])->str |None :\n    \"\"\"Elige un archivo existente al azar (o None si no hay).\"\"\"\n    if not names :\n        return None \n    return rng .choice (names )\n\ndef _compute_offset_and_len (\nrng :random .Random ,\nsize_blocks :int ,\naccess_mode :str ,\nseq_cursor :int |None ,\nmax_io_blocks :int ,\n)->Tuple [int ,int ,int ]:\n    \"\"\"\n    Devuelve (offset, n_blocks, new_cursor). Asegura que offset+n_blocks <= size_blocks.\n    - Para 'seq', usa el cursor actual (o 0) y lo avanza.\n    - Para 'rand', elige un offset válido al azar.\n    \"\"\"\n    if size_blocks <=0 :\n        return 0 ,0 ,seq_cursor or 0 \n\n\n    n_blocks =rng .randint (1 ,min (max_io_blocks ,size_blocks ))\n\n    if access_mode ==\"seq\":\n        cur =seq_cursor or 0 \n        if cur >=size_blocks :\n            cur =0 \n\n        if cur +n_blocks >size_blocks :\n            n_blocks =size_blocks -cur \n            if n_blocks <=0 :\n                n_blocks =1 \n                cur =0 \n        offset =cur \n        new_cursor =(cur +n_blocks )%size_blocks if size_blocks >0 else 0 \n        return offset ,n_blocks ,new_cursor \n    else :\n\n        if n_blocks >=size_blocks :\n            offset =0 \n            n_blocks =size_blocks \n        else :\n            offset =rng .randint (0 ,size_blocks -n_blocks )\n        return offset ,n_blocks ,seq_cursor or 0 \n\n\n\ndef generate_workload (\ncfg :Dict [str ,Any ],\nseed :int |None =None ,\n*,\nuser_files :Optional [List [Dict [str ,Any ]]]=None ,\nrespect_user_files_only :bool =False ,\n)->List [Dict [str ,Any ]]:\n    \"\"\"\n    Genera una lista de operaciones realista para el simulador.\n\n    Requisitos del cfg (normalizado por scenario_definitions.get_config):\n      - disk_size (int), block_size (int)\n      - n_files_small (int), file_small_range (tuple[min,max])\n      - n_files_large (int), file_large_range (tuple[min,max])\n      - access_pattern: {'seq': float, 'rand': float} con suma 1.0\n      - delete_rate (0..1), ops (int)\n      - (opcional) max_io_blocks (int): límite superior de bloques por op de IO (default 8)\n\n    Parámetros nuevos:\n      - user_files: lista opcional de archivos manuales a poblar inicialmente.\n          Formato por elemento: {'name': str, 'size_blocks': int (>0)}\n      - respect_user_files_only: si True, NO se genera población inicial aleatoria\n          (n_files_small/large se ignoran). El resto del flujo (create/delete/read/write)\n          permanece igual (es decir, puede haber creates dinámicos más adelante).\n\n    Estrategia:\n      1) Población inicial:\n         - Si user_files viene: se emiten 'create' para cada archivo.\n         - Si respect_user_files_only es False: además, se crean archivos según\n           n_files_small/n_files_large.\n      2) Flujo de 'ops' operaciones: mezcla create/delete/read/write según pesos\n         derivados de delete_rate, garantizando operaciones válidas (p. ej., no leer si no hay archivos).\n      3) Para 'seq', mantiene un cursor por archivo; para 'rand', elige offset al azar.\n    \"\"\"\n    rng =random .Random (seed )\n    ops :List [Dict [str ,Any ]]=[]\n\n\n    n_ops :int =int (cfg .get (\"ops\",1000 ))\n    n_small :int =int (cfg .get (\"n_files_small\",0 ))\n    n_large :int =int (cfg .get (\"n_files_large\",0 ))\n    small_rng :Tuple [int ,int ]=tuple (cfg .get (\"file_small_range\",(1 ,4 )))\n    large_rng :Tuple [int ,int ]=tuple (cfg .get (\"file_large_range\",(16 ,128 )))\n    seq_prob :float =float (cfg .get (\"access_pattern\",{}).get (\"seq\",0.5 ))\n    delete_rate :float =float (cfg .get (\"delete_rate\",0.1 ))\n    max_io_blocks :int =int (cfg .get (\"max_io_blocks\",8 ))\n\n\n    files :Dict [str ,Dict [str ,int ]]={}\n    live_names :List [str ]=[]\n    existing_names :Set [str ]=set ()\n\n\n    counter_small =0 \n    counter_large =0 \n\n\n\n\n    if user_files :\n\n        for idx ,uf in enumerate (user_files ):\n            if not isinstance (uf ,dict ):\n                raise ValueError (f\"user_files[{idx }] debe ser dict con 'name' y 'size_blocks'\")\n            name =uf .get (\"name\")\n            size =uf .get (\"size_blocks\")\n            if not isinstance (name ,str )or not name :\n                raise ValueError (f\"user_files[{idx }]: 'name' debe ser str no vacío\")\n            if not isinstance (size ,int )or size <=0 :\n                raise ValueError (f\"user_files[{idx }]: 'size_blocks' debe ser int > 0\")\n            if name in existing_names :\n                raise ValueError (f\"user_files: nombre duplicado: '{name }'\")\n\n            files [name ]={\"size\":size ,\"cursor\":0 }\n            live_names .append (name )\n            existing_names .add (name )\n            ops .append ({\n            \"op\":\"create\",\n            \"name\":name ,\n            \"size_blocks\":size ,\n            \"offset\":0 ,\n            \"n_blocks\":0 ,\n            \"access_mode\":\"seq\",\n            })\n\n\n\n\n    if not respect_user_files_only :\n\n        for _ in range (n_small ):\n\n            name ,counter_small =_next_unique_name (\"small\",counter_small ,existing_names )\n            size =_rand_size (rng ,small_rng )\n            files [name ]={\"size\":size ,\"cursor\":0 }\n            live_names .append (name )\n            existing_names .add (name )\n            ops .append ({\"op\":\"create\",\"name\":name ,\"size_blocks\":size ,\"offset\":0 ,\"n_blocks\":0 ,\"access_mode\":\"seq\"})\n\n        for _ in range (n_large ):\n            name ,counter_large =_next_unique_name (\"large\",counter_large ,existing_names )\n            size =_rand_size (rng ,large_rng )\n            files [name ]={\"size\":size ,\"cursor\":0 }\n            live_names .append (name )\n            existing_names .add (name )\n            ops .append ({\"op\":\"create\",\"name\":name ,\"size_blocks\":size ,\"offset\":0 ,\"n_blocks\":0 ,\"access_mode\":\"seq\"})\n\n\n\n\n    weights =_ensure_min_ops_weights (delete_rate )\n    kinds_for_create =[\"small\",\"large\"]\n    kind_probs =[0.75 ,0.25 ]\n\n    for _ in range (n_ops ):\n\n        if not live_names :\n            chosen =\"create\"\n        else :\n            chosen =rng .choices ([\"create\",\"delete\",\"read\",\"write\"],weights =weights ,k =1 )[0 ]\n\n        if chosen ==\"create\":\n            kind =rng .choices (kinds_for_create ,weights =kind_probs ,k =1 )[0 ]\n            if kind ==\"small\":\n                name ,counter_small =_next_unique_name (\"small\",counter_small ,existing_names )\n                size =_rand_size (rng ,small_rng )\n            else :\n                name ,counter_large =_next_unique_name (\"large\",counter_large ,existing_names )\n                size =_rand_size (rng ,large_rng )\n\n            files [name ]={\"size\":size ,\"cursor\":0 }\n            live_names .append (name )\n            existing_names .add (name )\n\n            ops .append ({\n            \"op\":\"create\",\n            \"name\":name ,\n            \"size_blocks\":size ,\n            \"offset\":0 ,\n            \"n_blocks\":0 ,\n            \"access_mode\":\"seq\",\n            })\n\n        elif chosen ==\"delete\":\n\n            victim =_pick_existing (rng ,live_names )\n            if victim is None :\n\n                kind =rng .choices (kinds_for_create ,weights =kind_probs ,k =1 )[0 ]\n                if kind ==\"small\":\n                    name ,counter_small =_next_unique_name (\"small\",counter_small ,existing_names )\n                    size =_rand_size (rng ,small_rng )\n                else :\n                    name ,counter_large =_next_unique_name (\"large\",counter_large ,existing_names )\n                    size =_rand_size (rng ,large_rng )\n                files [name ]={\"size\":size ,\"cursor\":0 }\n                live_names .append (name )\n                existing_names .add (name )\n                ops .append ({\"op\":\"create\",\"name\":name ,\"size_blocks\":size ,\"offset\":0 ,\"n_blocks\":0 ,\"access_mode\":\"seq\"})\n            else :\n                ops .append ({\n                \"op\":\"delete\",\n                \"name\":victim ,\n                \"size_blocks\":0 ,\n                \"offset\":0 ,\n                \"n_blocks\":0 ,\n                \"access_mode\":\"seq\",\n                })\n\n                live_names .remove (victim )\n                existing_names .discard (victim )\n                files .pop (victim ,None )\n\n        elif chosen in (\"read\",\"write\"):\n            target =_pick_existing (rng ,live_names )\n            if target is None :\n\n                kind =rng .choices (kinds_for_create ,weights =kind_probs ,k =1 )[0 ]\n                if kind ==\"small\":\n                    name ,counter_small =_next_unique_name (\"small\",counter_small ,existing_names )\n                    size =_rand_size (rng ,small_rng )\n                else :\n                    name ,counter_large =_next_unique_name (\"large\",counter_large ,existing_names )\n                    size =_rand_size (rng ,large_rng )\n                files [name ]={\"size\":size ,\"cursor\":0 }\n                live_names .append (name )\n                existing_names .add (name )\n                ops .append ({\"op\":\"create\",\"name\":name ,\"size_blocks\":size ,\"offset\":0 ,\"n_blocks\":0 ,\"access_mode\":\"seq\"})\n                continue \n\n\n            size =files [target ][\"size\"]\n            access_mode =_choose_access_mode (rng ,seq_prob )\n            cursor =files [target ][\"cursor\"]\n            offset ,n_blocks ,new_cursor =_compute_offset_and_len (\n            rng ,size ,access_mode ,cursor ,max_io_blocks \n            )\n            files [target ][\"cursor\"]=new_cursor \n\n            ops .append ({\n            \"op\":chosen ,\n            \"name\":target ,\n            \"size_blocks\":0 ,\n            \"offset\":offset ,\n            \"n_blocks\":n_blocks ,\n            \"access_mode\":access_mode ,\n            })\n\n        else :\n\n            name ,counter_small =_next_unique_name (\"small\",counter_small ,existing_names )\n            size =_rand_size (rng ,small_rng )\n            files [name ]={\"size\":size ,\"cursor\":0 }\n            live_names .append (name )\n            existing_names .add (name )\n            ops .append ({\"op\":\"create\",\"name\":name ,\"size_blocks\":size ,\"offset\":0 ,\"n_blocks\":0 ,\"access_mode\":\"seq\"})\n\n    return ops \n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\ui\\app.py": "\nimport customtkinter as ctk \nfrom .main_view import MainView \n\n\nPALETTE ={\n\"app_bg\":\"#320A6B\",\n\"frame_bg\":\"#065084\",\n\"button\":\"#0F828C\",\n\"button_hover\":\"#78B9B5\",\n\"text_light\":\"#78B9B5\",\n\"text_on_button\":\"#FFFFFF\"\n}\n\ndef main ():\n    \"\"\"\n    Punto de entrada principal para la aplicación de UI (opcional).\n    \"\"\"\n    try :\n        ctk .set_appearance_mode (\"dark\")\n\n        app =ctk .CTk ()\n        app .title (\"FSim - Simulador de Sistemas de Archivos\")\n        app .geometry (\"1100x700\")\n\n\n        app .configure (fg_color =PALETTE [\"app_bg\"])\n\n\n        main_view =MainView (master =app ,palette =PALETTE )\n        main_view .pack (fill =\"both\",expand =True ,padx =10 ,pady =10 )\n\n        app .mainloop ()\n\n    except ImportError :\n        print (\"Error: 'customtkinter' no está instalado.\")\n        print (\"Ejecuta 'pip install customtkinter' para usar la UI.\")\n        print (\"Como alternativa, usa la CLI: python -m fsim ...\")\n    except Exception as e :\n        print (f\"No se pudo iniciar la UI: {e }\")\n        print (\"Asegúrate de tener un entorno gráfico (DISPLAY) disponible.\")\n        print (\"Como alternativa, usa la CLI: python -m fsim ...\")\n\n\nif __name__ ==\"__main__\":\n    main ()", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\ui\\charts_view.py": "\nimport customtkinter as ctk \nfrom tkinter import ttk \nimport tkinter as tk \nfrom typing import Dict ,Any ,List ,Optional \nimport matplotlib .pyplot as plt \nfrom matplotlib .figure import Figure \nfrom matplotlib .backends .backend_tkagg import FigureCanvasTkAgg ,NavigationToolbar2Tk \nimport numpy as np \n\nclass SpanishNavigationToolbar (NavigationToolbar2Tk ):\n    \"\"\"NavigationToolbar con tooltips y mensajes en español.\"\"\"\n\n    toolitems =(\n    ('Home','Resetear vista original','home','home'),\n    ('Back','Volver a vista previa','back','back'),\n    ('Forward','Siguiente vista','forward','forward'),\n    (None ,None ,None ,None ),\n    ('Pan','Mover arrastrando','move','pan'),\n    ('Zoom','Zoom a región','zoom_to_rect','zoom'),\n    ('Subplots','Configurar subplots','subplots','configure_subplots'),\n    (None ,None ,None ,None ),\n    ('Save','Guardar figura','filesave','save_figure'),\n    )\n\n    def set_message (self ,msg ):\n        \"\"\"Traduce los mensajes de estado comunes.\"\"\"\n        translations ={\n        'Mouse position: ':'Posición del mouse: ',\n        'Navigation: ':'Navegación: ',\n        'Left button: ':'Botón izquierdo: ',\n        'Right button: ':'Botón derecho: ',\n        'Middle button: ':'Botón central: ',\n        'Pan axes':'Mover ejes',\n        'Zoom to rectangle':'Zoom a rectángulo',\n        'Press left button to zoom':'Click izquierdo para hacer zoom',\n        'Reset original view':'Restaurar vista original',\n        'Save the figure':'Guardar la figura',\n        'Configure subplots':'Configurar subplots'\n        }\n\n        for en ,es in translations .items ():\n            if msg .startswith (en ):\n                msg =msg .replace (en ,es )\n                break \n\n        super ().set_message (msg )\n\nSTRATEGY_NAMES_ES ={\n\"contiguous\":\"Asignación Contigua\",\n\"linked\":\"Asignación Enlazada\",\n\"indexed\":\"Asignación Indexada\",\n\n}\n\n\nplt .style .use ('dark_background')\n\n\nTIMESERIES_PLOTS ={\n\"access_time_ms\":\"Tiempo Acceso (ms)\",\n\"external_frag_pct\":\"Frag. Externa (%)\",\n\"space_usage_pct\":\"Uso Espacio (%)\",\n\n}\n\n\nTHROUGHPUT_WINDOWS =[20 ,50 ,100 ]\n\nclass ChartsView (ctk .CTkFrame ):\n    \"\"\"\n    Vista para mostrar gráficos de las trazas de operación (op_traces).\n    \"\"\"\n    def __init__ (self ,master ,palette :Dict [str ,str ],**kwargs ):\n        super ().__init__ (master ,**kwargs )\n        self .palette =palette \n        self .configure (fg_color =\"transparent\")\n\n        self ._summaries_data :Optional [Dict [str ,Any ]]=None \n        self ._strategy_keys :List [str ]=[]\n        self ._current_strategy :str =\"\"\n        self ._current_traces :List [Dict [str ,Any ]]=[]\n\n        self .grid_columnconfigure (0 ,weight =1 )\n        self .grid_rowconfigure (1 ,weight =1 )\n\n\n        controls_frame =ctk .CTkFrame (self ,fg_color =\"transparent\")\n        controls_frame .grid (row =0 ,column =0 ,sticky =\"ew\",padx =10 ,pady =(0 ,10 ))\n        controls_frame .grid_columnconfigure (1 ,weight =1 )\n\n\n        ctk .CTkLabel (controls_frame ,text =\"Seleccionar Estrategia:\",text_color =self .palette [\"text_light\"]).grid (row =0 ,column =0 ,padx =(0 ,10 ),sticky =\"w\")\n        self .strategy_var =ctk .StringVar (value =\"Ninguna\")\n        self .strategy_combo =ctk .CTkComboBox (\n        controls_frame ,variable =self .strategy_var ,values =[\"Ninguna\"],\n        state =\"disabled\",command =self ._on_strategy_change ,\n        text_color =self .palette [\"text_on_button\"],\n        fg_color =self .palette [\"button\"],\n        button_color =self .palette [\"button\"],\n        border_color =self .palette [\"button\"],\n        dropdown_fg_color =self .palette [\"frame_bg\"],\n        dropdown_hover_color =self .palette [\"button_hover\"],\n        dropdown_text_color =self .palette [\"text_light\"]\n        )\n        self .strategy_combo .grid (row =0 ,column =1 ,sticky =\"ew\")\n\n\n        ctk .CTkLabel (controls_frame ,text =\"Ventana Throughput (ops):\",text_color =self .palette [\"text_light\"]).grid (row =0 ,column =2 ,padx =(20 ,10 ),sticky =\"w\")\n        self .throughput_win_var =ctk .StringVar (value =str (THROUGHPUT_WINDOWS [1 ]))\n        self .throughput_win_combo =ctk .CTkComboBox (\n        controls_frame ,variable =self .throughput_win_var ,values =[str (w )for w in THROUGHPUT_WINDOWS ],\n        state =\"disabled\",command =self ._redraw_charts ,width =80 ,\n        text_color =self .palette [\"text_on_button\"],\n        fg_color =self .palette [\"button\"],\n        button_color =self .palette [\"button\"],\n        border_color =self .palette [\"button\"],\n        dropdown_fg_color =self .palette [\"frame_bg\"],\n        dropdown_hover_color =self .palette [\"button_hover\"],\n        dropdown_text_color =self .palette [\"text_light\"]\n        )\n        self .throughput_win_combo .grid (row =0 ,column =3 ,sticky =\"w\")\n\n\n        self .tab_view =ctk .CTkTabview (self ,\n        fg_color =self .palette [\"frame_bg\"],\n        segmented_button_selected_color =self .palette [\"button\"],\n        segmented_button_selected_hover_color =self .palette [\"button_hover\"],\n        segmented_button_unselected_color =self .palette [\"frame_bg\"],\n        text_color =self .palette [\"text_light\"]\n        )\n        self .tab_view .grid (row =1 ,column =0 ,sticky =\"nsew\",padx =10 ,pady =10 )\n\n\n\n        self ._chart_widgets :Dict [str ,Any ]={}\n        self ._create_placeholder_tab (\"Esperando datos...\")\n\n    def _create_placeholder_tab (self ,text :str ):\n        \"\"\"Creates a tab with a simple placeholder label.\"\"\"\n        try :\n            tab =self .tab_view .add (\"Info\")\n            tab .grid_columnconfigure (0 ,weight =1 );tab .grid_rowconfigure (0 ,weight =1 )\n            label =ctk .CTkLabel (tab ,text =text ,text_color =self .palette [\"text_light\"],font =ctk .CTkFont (size =16 ))\n            label .grid (row =0 ,column =0 ,padx =20 ,pady =20 )\n        except Exception as e :\n            print (f\"Error creating placeholder tab: {e }\")\n\n    def _clear_tabs (self ):\n        \"\"\"Removes all existing tabs.\"\"\"\n\n        tab_names =list (self .tab_view ._name_list )\n        for name in tab_names :\n            try :\n                self .tab_view .delete (name )\n            except Exception as e :\n                print (f\"Error deleting tab '{name }': {e }\")\n\n        for widget_set in self ._chart_widgets .values ():\n            if widget_set .get ('canvas_widget'):\n                widget_set ['canvas_widget'].destroy ()\n            if widget_set .get ('toolbar_widget'):\n                 widget_set ['toolbar_widget'].destroy ()\n            if widget_set .get ('fig'):\n                 plt .close (widget_set ['fig'])\n        self ._chart_widgets ={}\n\n\n    def _create_chart_tabs (self ):\n        \"\"\"Creates the necessary tabs and embedded matplotlib figures.\"\"\"\n        self ._clear_tabs ()\n        if not self ._current_traces :\n            self ._create_placeholder_tab (\"No hay datos de traza para esta estrategia.\")\n            return \n\n        plot_keys =[\n        \"access_time_ms\",\n        \"external_frag_pct\",\n        \"space_usage_pct\",\n        \"cumulative_seeks\",\n        \"throughput\",\n        \"latency_vs_throughput\"\n        ]\n\n        for key in plot_keys :\n\n            tab_name ={\n            \"access_time_ms\":\"Tiempo de Acceso\",\n            \"external_frag_pct\":\"Fragmentación Externa\",\n            \"space_usage_pct\":\"Uso de Espacio\",\n            \"cumulative_seeks\":\"Búsquedas Acumuladas\",\n            \"throughput\":\"Throughput\",\n            \"latency_vs_throughput\":\"Latencia vs Throughput\"\n            }.get (key ,key .replace (\"_\",\" \").title ())\n\n            try :\n                tab =self .tab_view .add (tab_name )\n                tab .grid_columnconfigure (0 ,weight =1 );tab .grid_rowconfigure (0 ,weight =1 )\n\n                fig =Figure (figsize =(8 ,4 ),dpi =100 ,facecolor =self .palette [\"frame_bg\"])\n                ax =fig .add_subplot (111 )\n                ax .set_facecolor (self .palette [\"app_bg\"])\n                ax .tick_params (axis ='x',colors =self .palette [\"text_light\"])\n                ax .tick_params (axis ='y',colors =self .palette [\"text_light\"])\n                ax .spines ['bottom'].set_color (self .palette [\"text_light\"])\n                ax .spines ['left'].set_color (self .palette [\"text_light\"])\n                ax .spines ['top'].set_color (self .palette [\"frame_bg\"])\n                ax .spines ['right'].set_color (self .palette [\"frame_bg\"])\n                fig .subplots_adjust (left =0.1 ,right =0.95 ,top =0.9 ,bottom =0.15 )\n\n                canvas =FigureCanvasTkAgg (fig ,master =tab )\n                canvas_widget =canvas .get_tk_widget ()\n                canvas_widget .pack (side =tk .TOP ,fill =tk .BOTH ,expand =True )\n\n                toolbar_frame =ctk .CTkFrame (tab ,fg_color =\"transparent\")\n                toolbar_frame .pack (side =tk .BOTTOM ,fill =tk .X )\n                toolbar =SpanishNavigationToolbar (canvas ,toolbar_frame ,pack_toolbar =False )\n\n\n                toolbar .configure (background =self .palette [\"frame_bg\"])\n\n                try :\n                    toolbar ._message_label .config (background =self .palette [\"frame_bg\"],fg =self .palette [\"text_light\"])\n                except AttributeError :\n                    pass \n\n\n                for item in toolbar .winfo_children ():\n                    if isinstance (item ,(tk .Button ,tk .Checkbutton ,tk .Radiobutton )):\n                         try :\n                              item .config (\n                              background =self .palette [\"button\"],\n                              foreground =self .palette [\"text_on_button\"],\n                              activebackground =self .palette [\"button_hover\"],\n                              activeforeground =self .palette [\"text_on_button\"],\n                              relief =tk .FLAT ,\n                              bd =0 \n                              )\n                         except tk .TclError as e :\n\n\n                              pass \n                    elif isinstance (item ,tk .Frame ):\n                        item .config (background =self .palette [\"frame_bg\"])\n\n\n                toolbar .pack (side =tk .LEFT ,padx =10 )\n\n                self ._chart_widgets [key ]={'fig':fig ,'ax':ax ,'canvas':canvas ,'canvas_widget':canvas_widget ,'toolbar':toolbar ,'toolbar_frame':toolbar_frame }\n\n            except Exception as e :\n                print (f\"Error creating tab/chart for '{key }': {e }\")\n                try :\n                    error_tab =self .tab_view .add (f\"{tab_name } Error\")\n                    ctk .CTkLabel (error_tab ,text =f\"Error al crear gráfico:\\n{e }\",text_color =\"red\").pack (padx =10 ,pady =10 )\n                except :pass \n\n        if self .tab_view ._name_list :\n             self .tab_view .set (self .tab_view ._name_list [0 ])\n\n\n    def _plot_timeseries (self ,key :str ,ax :plt .Axes ,canvas :FigureCanvasTkAgg ):\n        \"\"\"Plots a simple time series from op_traces.\"\"\"\n        y_label =TIMESERIES_PLOTS .get (key ,key )\n        x_data =[t .get (\"op_index\",i )for i ,t in enumerate (self ._current_traces )]\n        y_data =[t .get (key ,0 )for t in self ._current_traces ]\n\n\n        step =1 \n        if len (x_data )>2000 :\n            step =len (x_data )//1000 \n\n        ax .clear ()\n        ax .plot (x_data [::step ],y_data [::step ],color =self .palette [\"button_hover\"],linewidth =1.5 )\n        ax .set_title (y_label ,color =self .palette [\"text_light\"])\n        ax .set_xlabel (\"Índice de Operación\",color =self .palette [\"text_light\"])\n        ax .set_ylabel (y_label ,color =self .palette [\"text_light\"])\n        ax .grid (True ,linestyle ='--',alpha =0.3 ,color =self .palette [\"text_light\"])\n        canvas .draw ()\n\n    def _plot_cumulative_seeks (self ,ax :plt .Axes ,canvas :FigureCanvasTkAgg ):\n        \"\"\"Plots cumulative estimated seeks.\"\"\"\n        x_data =[t .get (\"op_index\",i )for i ,t in enumerate (self ._current_traces )]\n        y_data_raw =[t .get (\"seeks_est\",0 )for t in self ._current_traces ]\n        y_data_cumulative =np .cumsum (y_data_raw )\n\n        step =1 \n        if len (x_data )>2000 :step =len (x_data )//1000 \n\n        ax .clear ()\n        ax .plot (x_data [::step ],y_data_cumulative [::step ],color =self .palette [\"button_hover\"],linewidth =1.5 )\n        ax .set_title (\"Seeks Estimados (Acumulado)\",color =self .palette [\"text_light\"])\n        ax .set_xlabel (\"Índice de Operación\",color =self .palette [\"text_light\"])\n        ax .set_ylabel (\"Total Seeks\",color =self .palette [\"text_light\"])\n        ax .grid (True ,linestyle ='--',alpha =0.3 ,color =self .palette [\"text_light\"])\n        canvas .draw ()\n\n    def _plot_throughput (self ,ax :plt .Axes ,canvas :FigureCanvasTkAgg ):\n        \"\"\"Plots moving average throughput.\"\"\"\n        try :\n            window =int (self .throughput_win_var .get ())\n        except :\n            window =THROUGHPUT_WINDOWS [1 ]\n\n        x_data =np .array ([t .get (\"op_index\",i )for i ,t in enumerate (self ._current_traces )])\n\n        time_stamps =np .array ([t .get (\"t_wall_from_start_s\",0 )for t in self ._current_traces ])\n        delta_times =np .diff (time_stamps ,prepend =0 )\n        delta_times [delta_times <=0 ]=1e-6 \n\n\n        instant_throughput =1.0 /delta_times \n\n\n\n\n        if len (instant_throughput )>=window :\n             weights =np .ones (window )/window \n             moving_avg_throughput =np .convolve (instant_throughput ,weights ,mode ='valid')\n\n             x_data_avg =x_data [window -1 :]\n        else :\n             moving_avg_throughput =[]\n             x_data_avg =[]\n\n\n        step =1 \n        if len (x_data_avg )>2000 :step =len (x_data_avg )//1000 \n\n        ax .clear ()\n        if len (x_data_avg )>0 :\n             ax .plot (x_data_avg [::step ],moving_avg_throughput [::step ],color =self .palette [\"button_hover\"],linewidth =1.5 )\n        else :\n             ax .text (0.5 ,0.5 ,\"Datos insuficientes para la ventana\",ha ='center',va ='center',color =self .palette [\"text_light\"])\n\n        ax .set_title (f\"Throughput (Ops/s, Ventana Móvil={window })\",color =self .palette [\"text_light\"])\n        ax .set_xlabel (\"Índice de Operación\",color =self .palette [\"text_light\"])\n        ax .set_ylabel (\"Ops / Segundo\",color =self .palette [\"text_light\"])\n        ax .grid (True ,linestyle ='--',alpha =0.3 ,color =self .palette [\"text_light\"])\n        ax .set_ylim (bottom =0 )\n        canvas .draw ()\n\n    def _plot_latency_vs_throughput (self ,ax :plt .Axes ,canvas :FigureCanvasTkAgg ):\n        \"\"\"Scatter plot of latency vs throughput (using moving averages).\"\"\"\n        try :\n            window =int (self .throughput_win_var .get ())\n        except :\n            window =THROUGHPUT_WINDOWS [1 ]\n\n\n        latencies =np .array ([t .get (\"access_time_ms\",0 )for t in self ._current_traces ])\n        moving_avg_latency =[]\n        if len (latencies )>=window :\n            weights =np .ones (window )/window \n            moving_avg_latency =np .convolve (latencies ,weights ,mode ='valid')\n\n\n        time_stamps =np .array ([t .get (\"t_wall_from_start_s\",0 )for t in self ._current_traces ])\n        delta_times =np .diff (time_stamps ,prepend =0 )\n        delta_times [delta_times <=0 ]=1e-6 \n        instant_throughput =1.0 /delta_times \n        moving_avg_throughput =[]\n        if len (instant_throughput )>=window :\n             weights =np .ones (window )/window \n             moving_avg_throughput =np .convolve (instant_throughput ,weights ,mode ='valid')\n\n\n        min_len =min (len (moving_avg_latency ),len (moving_avg_throughput ))\n        scatter_latency =moving_avg_latency [:min_len ]\n        scatter_throughput =moving_avg_throughput [:min_len ]\n\n        ax .clear ()\n        if min_len >0 :\n\n            ax .scatter (scatter_latency ,scatter_throughput ,color =self .palette [\"button_hover\"],alpha =0.6 ,s =10 )\n        else :\n            ax .text (0.5 ,0.5 ,\"Datos insuficientes para la ventana\",ha ='center',va ='center',color =self .palette [\"text_light\"])\n\n        ax .set_title (f\"Latencia vs Throughput (Ventana={window })\",color =self .palette [\"text_light\"])\n        ax .set_xlabel (\"Latencia Promedio (ms)\",color =self .palette [\"text_light\"])\n        ax .set_ylabel (\"Throughput Promedio (Ops/s)\",color =self .palette [\"text_light\"])\n        ax .grid (True ,linestyle ='--',alpha =0.3 ,color =self .palette [\"text_light\"])\n        ax .set_xlim (left =0 )\n        ax .set_ylim (bottom =0 )\n        canvas .draw ()\n\n\n    def _redraw_charts (self ,*args ):\n        \"\"\"Redraws all charts for the currently selected strategy.\"\"\"\n        if not self ._current_strategy or not self ._summaries_data or not self ._current_traces :\n\n             return \n\n\n\n\n        for key ,widgets in self ._chart_widgets .items ():\n            if key in TIMESERIES_PLOTS :\n                self ._plot_timeseries (key ,widgets ['ax'],widgets ['canvas'])\n\n\n        if \"cumulative_seeks\"in self ._chart_widgets :\n             widgets =self ._chart_widgets [\"cumulative_seeks\"]\n             self ._plot_cumulative_seeks (widgets ['ax'],widgets ['canvas'])\n\n\n        if \"throughput\"in self ._chart_widgets :\n            widgets =self ._chart_widgets [\"throughput\"]\n            self ._plot_throughput (widgets ['ax'],widgets ['canvas'])\n\n\n        if \"latency_vs_throughput\"in self ._chart_widgets :\n            widgets =self ._chart_widgets [\"latency_vs_throughput\"]\n            self ._plot_latency_vs_throughput (widgets ['ax'],widgets ['canvas'])\n\n\n    def _on_strategy_change (self ,selected_strategy_display :str ):\n        \"\"\"Callback when the user selects a different strategy.\"\"\"\n        if not self ._summaries_data :return \n\n\n        strategy_key =\"\"\n\n        strategy_map_en ={STRATEGY_NAMES_ES .get (k ,k ):k for k in self ._strategy_keys }\n        strategy_key =strategy_map_en .get (selected_strategy_display )\n\n        if strategy_key and strategy_key in self ._summaries_data :\n            self ._current_strategy =strategy_key \n            self ._current_traces =self ._summaries_data [strategy_key ].get (\"op_traces\",[])\n\n            if not self ._chart_widgets :\n                 self ._create_chart_tabs ()\n            self ._redraw_charts ()\n        else :\n\n            self ._current_strategy =\"\"\n            self ._current_traces =[]\n            self ._clear_tabs ()\n            self ._create_placeholder_tab (f\"No hay datos para '{selected_strategy_display }'.\")\n\n\n    def update_charts (self ,summaries :Optional [Dict [str ,Any ]]):\n        \"\"\"\n        Punto de entrada principal. Recibe los summaries completos\n        y actualiza la vista de gráficos.\n        \"\"\"\n        self ._summaries_data =summaries \n        self ._strategy_keys =[]\n        self ._current_strategy =\"\"\n        self ._current_traces =[]\n        self ._clear_tabs ()\n\n        if summaries is None or \"error\"in summaries or not summaries :\n            self .strategy_combo .configure (state =\"disabled\",values =[\"Ninguna\"])\n            self .strategy_var .set (\"Ninguna\")\n            self .throughput_win_combo .configure (state =\"disabled\")\n            error_msg =summaries .get (\"error\",\"No se recibieron resultados.\")if summaries else \"No se recibieron resultados.\"\n            self ._create_placeholder_tab (f\"Error en la simulación:\\n{error_msg }\")\n            return \n\n\n        valid_strategies =[]\n        for strat_key ,data in summaries .items ():\n            if not strat_key .startswith (\"_\")and \"op_traces\"in data and data [\"op_traces\"]:\n                 self ._strategy_keys .append (strat_key )\n\n                 display_name =STRATEGY_NAMES_ES .get (strat_key ,strat_key )\n                 valid_strategies .append (display_name )\n\n\n        if not valid_strategies :\n            self .strategy_combo .configure (state =\"disabled\",values =[\"Sin Datos\"])\n            self .strategy_var .set (\"Sin Datos\")\n            self .throughput_win_combo .configure (state =\"disabled\")\n            self ._create_placeholder_tab (\"La simulación no generó trazas de operaciones.\")\n            return \n\n\n        self .strategy_combo .configure (state =\"normal\",values =valid_strategies )\n        self .throughput_win_combo .configure (state =\"normal\")\n\n        first_strategy_display =valid_strategies [0 ]\n        self .strategy_var .set (first_strategy_display )\n        self ._on_strategy_change (first_strategy_display )", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\ui\\disk_view.py": "\nimport customtkinter as ctk \nfrom typing import Dict ,Any ,List ,Optional \nimport time \n\n\nBLOCK_SIZE_PX =4 \nBLOCK_PAD_PX =1 \nCOLS =170 \n\nclass DiskView (ctk .CTkFrame ):\n    \"\"\"\n    Vista para la visualización del bitmap del disco (En Vivo).\n    Implementa \"throttling\", optimización de dibujo (run-length),\n    y manejo extra-robusto de bitmaps inválidos/dimensiones cero.\n    \"\"\"\n    def __init__ (self ,master ,palette :Dict [str ,str ],**kwargs ):\n        super ().__init__ (master ,**kwargs )\n        self .palette =palette \n        self .configure (fg_color =\"transparent\")\n        self .grid_columnconfigure (0 ,weight =1 )\n        self .grid_rowconfigure (2 ,weight =1 )\n\n        self .COLOR_FREE =self .palette [\"button_hover\"]\n        self .COLOR_USED =self .palette [\"app_bg\"]\n\n        self .info_label =ctk .CTkLabel (\n        self ,text =\"Ejecuta una simulación para ver el estado del disco.\",\n        font =ctk .CTkFont (size =16 ),text_color =self .palette [\"text_light\"]\n        )\n        self .info_label .grid (row =0 ,column =0 ,padx =10 ,pady =(0 ,5 ),sticky =\"w\")\n\n        self .legend_frame =ctk .CTkFrame (self ,fg_color =\"transparent\")\n        self .legend_frame .grid (row =1 ,column =0 ,padx =15 ,pady =0 ,sticky =\"w\")\n\n        self .legend_used_color =ctk .CTkFrame (self .legend_frame ,width =15 ,height =15 ,fg_color =self .COLOR_USED ,border_width =1 ,border_color =self .palette [\"button_hover\"]);self .legend_used_color .pack (side =\"left\",padx =(0 ,5 ))\n        self .legend_used_label =ctk .CTkLabel (self .legend_frame ,text =\"Ocupado\",text_color =self .palette [\"text_light\"]);self .legend_used_label .pack (side =\"left\",padx =(0 ,20 ))\n        self .legend_free_color =ctk .CTkFrame (self .legend_frame ,width =15 ,height =15 ,fg_color =self .COLOR_FREE ,border_width =0 );self .legend_free_color .pack (side =\"left\",padx =(0 ,5 ))\n        self .legend_free_label =ctk .CTkLabel (self .legend_frame ,text =\"Libre\",text_color =self .palette [\"text_light\"]);self .legend_free_label .pack (side =\"left\",padx =(0 ,20 ))\n\n        self .scroll_frame =ctk .CTkScrollableFrame (self ,fg_color =\"transparent\")\n        self .scroll_frame .grid (row =2 ,column =0 ,sticky =\"nsew\")\n        self .scroll_frame .grid_columnconfigure (0 ,weight =1 )\n\n        self ._current_scroll_row =0 \n        self ._live_canvas :Optional [ctk .CTkCanvas ]=None \n        self ._live_canvas_strategy =\"\"\n        self ._last_live_update_time =0.0 \n        self ._live_update_throttle_ms =50 \n\n    def _clear_bitmaps (self ):\n        for widget in self .scroll_frame .winfo_children ():\n            widget .destroy ()\n        self ._current_scroll_row =0 \n        self ._live_canvas =None \n        self ._live_canvas_strategy =\"\"\n\n    def _draw_run (self ,canvas :ctk .CTkCanvas ,start_index :int ,end_index :int ,value :int ):\n        \"\"\"Helper para dibujar un 'run' (rango) de bloques.\"\"\"\n        color =self .COLOR_FREE if value ==0 else self .COLOR_USED \n        current_index =start_index \n        while current_index <=end_index :\n            row =current_index //COLS \n            col_start =current_index %COLS \n            blocks_in_this_row =min (COLS -col_start ,(end_index -current_index )+1 )\n            col_end =col_start +blocks_in_this_row -1 \n\n            x1 =col_start *(BLOCK_SIZE_PX +BLOCK_PAD_PX )\n            y1 =row *(BLOCK_SIZE_PX +BLOCK_PAD_PX )\n            x2 =(col_end +1 )*(BLOCK_SIZE_PX +BLOCK_PAD_PX )-BLOCK_PAD_PX \n            y2 =y1 +BLOCK_SIZE_PX \n\n\n\n            safe_x1 =int (x1 )\n            safe_y1 =int (y1 )\n            safe_x2 =int (max (x1 +1 ,x2 ))\n            safe_y2 =int (max (y1 +1 ,y2 ))\n\n\n            if safe_x1 <safe_x2 and safe_y1 <safe_y2 :\n                 try :\n                      canvas .create_rectangle (safe_x1 ,safe_y1 ,safe_x2 ,safe_y2 ,fill =color ,outline =\"\")\n                 except Exception as draw_error :\n                      print (f\"Error drawing rectangle ({safe_x1 },{safe_y1 } -> {safe_x2 },{safe_y2 }): {draw_error }\")\n\n\n            current_index +=blocks_in_this_row \n\n\n    def _draw_bitmap (self ,\n    bitmap :List [int ],\n    strategy_name :str ,\n    canvas_instance :Optional [ctk .CTkCanvas ]=None \n    )->ctk .CTkCanvas :\n        \"\"\"Dibuja un bitmap en un canvas.\"\"\"\n\n        if not bitmap :\n            num_blocks =0 \n\n            canvas_width =1 \n            canvas_height =1 \n        else :\n            num_blocks =len (bitmap )\n            num_rows =(num_blocks //COLS )+1 \n            canvas_width =COLS *(BLOCK_SIZE_PX +BLOCK_PAD_PX )\n            canvas_height =num_rows *(BLOCK_SIZE_PX +BLOCK_PAD_PX )\n\n            canvas_width =max (1 ,canvas_width )\n            canvas_height =max (1 ,canvas_height )\n\n        canvas :ctk .CTkCanvas \n        if canvas_instance :\n            canvas =canvas_instance \n            try :\n\n                canvas .delete (\"all\")\n                canvas .configure (width =max (1 ,int (canvas_width )),height =max (1 ,int (canvas_height )))\n            except Exception as e :\n                print (f\"Error reconfigurando canvas existente: {e }\")\n                canvas =self ._create_new_canvas (strategy_name ,int (canvas_width ),int (canvas_height ))\n                self ._live_canvas =canvas \n        else :\n            canvas =self ._create_new_canvas (strategy_name ,int (canvas_width ),int (canvas_height ))\n\n\n        if num_blocks >0 and bitmap :\n            try :\n                current_run_val =bitmap [0 ]\n                current_run_start =0 \n                for i in range (1 ,num_blocks ):\n                    if bitmap [i ]!=current_run_val :\n                        self ._draw_run (canvas ,current_run_start ,i -1 ,current_run_val )\n                        current_run_val =bitmap [i ]\n                        current_run_start =i \n                self ._draw_run (canvas ,current_run_start ,num_blocks -1 ,current_run_val )\n            except IndexError as e :\n                 print (f\"Error dibujando runs (IndexError): {e }. Bitmap len={len (bitmap )}\")\n            except Exception as e :\n                 print (f\"Error inesperado dibujando runs: {e }\")\n\n        return canvas \n\n    def _create_new_canvas (self ,strategy_name :str ,canvas_width :int ,canvas_height :int )->ctk .CTkCanvas :\n        \"\"\"Helper para crear el título y el canvas, asegurando tamaño > 0.\"\"\"\n        title_label =ctk .CTkLabel (\n        self .scroll_frame ,text =f\"Estrategia: {strategy_name .upper ()}\",\n        font =ctk .CTkFont (size =16 ,weight =\"bold\"),text_color =self .palette [\"text_light\"]\n        )\n        title_label .grid (row =self ._current_scroll_row ,column =0 ,padx =10 ,pady =(15 ,5 ),sticky =\"w\")\n        self ._current_scroll_row +=1 \n\n\n        safe_width =max (1 ,int (canvas_width ))\n        safe_height =max (1 ,int (canvas_height ))\n\n        canvas =ctk .CTkCanvas (\n        self .scroll_frame ,bg =self .palette [\"frame_bg\"],highlightthickness =0 ,\n        width =safe_width ,height =safe_height \n        )\n        canvas .grid (row =self ._current_scroll_row ,column =0 ,pady =10 ,padx =10 )\n        self ._current_scroll_row +=1 \n        return canvas \n\n\n    def live_update (self ,strategy_name :str ,bitmap :List [int ]):\n        \"\"\"Punto de entrada llamado DESDE EL HILO DE SIMULACIÓN (vía runner).\"\"\"\n        current_time_s =time .monotonic ()\n        elapsed_ms =(current_time_s -self ._last_live_update_time )*1000.0 \n        if elapsed_ms <self ._live_update_throttle_ms :\n            return \n        self ._last_live_update_time =current_time_s \n\n        self .after (0 ,self ._safe_live_update ,strategy_name ,list (bitmap )if bitmap is not None else [])\n\n    def _safe_live_update (self ,strategy_name :str ,bitmap :List [int ]):\n        \"\"\"Esta función se ejecuta EN EL HILO PRINCIPAL de la UI.\"\"\"\n        try :\n            if not self .winfo_exists ():return \n\n\n\n\n            self .info_label .configure (text =f\"Simulando en vivo: {strategy_name .upper ()}...\")\n\n            if strategy_name !=self ._live_canvas_strategy :\n                self ._clear_bitmaps ()\n                self ._live_canvas_strategy =strategy_name \n                self ._live_canvas =self ._draw_bitmap (bitmap ,strategy_name ,canvas_instance =None )\n            elif self ._live_canvas is not None :\n\n                self ._draw_bitmap (bitmap ,strategy_name ,canvas_instance =self ._live_canvas )\n            else :\n\n                self ._live_canvas =self ._draw_bitmap (bitmap ,strategy_name ,canvas_instance =None )\n\n        except Exception as e :\n            print (f\"Error crítico en _safe_live_update: {e }\")\n\n\n    def show_final_snapshots (self ,bitmaps :Optional [Dict [str ,List [int ]]]):\n        \"\"\"Punto de entrada para los resultados FINALES.\"\"\"\n        self ._clear_bitmaps ()\n        if bitmaps is None :\n            self .info_label .configure (text =\"La simulación falló. No hay bitmap para mostrar.\")\n            return \n        if not bitmaps :\n            self .info_label .configure (text =\"No se recibieron bitmaps de la simulación.\")\n            return \n        self .info_label .configure (text =f\"Mostrando {len (bitmaps )} bitmap(s) finales:\")\n        for strategy_name ,bitmap_to_draw in bitmaps .items ():\n\n            safe_bitmap =bitmap_to_draw if bitmap_to_draw is not None else []\n            display_name =strategy_name \n            if bitmap_to_draw is None :\n                print (f\"Warning: Bitmap final para '{strategy_name }' es None.\")\n                display_name +=\" (Bitmap Inválido)\"\n            self ._draw_bitmap (safe_bitmap ,display_name ,canvas_instance =None )", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\ui\\main_view.py": "\nimport customtkinter as ctk \nfrom .scenario_view import ScenarioView \nfrom .results_view import ResultsView \nfrom .disk_view import DiskView \nfrom .charts_view import ChartsView \nfrom typing import Dict ,Any ,List ,Optional \n\nclass MainView (ctk .CTkFrame ):\n    \"\"\"\n    Vista principal que contiene la navegación (sidebar) y las vistas de página.\n    \"\"\"\n    def __init__ (self ,master ,palette :Dict [str ,str ],**kwargs ):\n        super ().__init__ (master ,**kwargs )\n        self .palette =palette \n\n        self .configure (fg_color =\"transparent\")\n        self .grid_columnconfigure (1 ,weight =1 )\n        self .grid_rowconfigure (0 ,weight =1 )\n\n\n        self .sidebar_frame =ctk .CTkFrame (self ,width =200 ,corner_radius =10 ,fg_color =self .palette [\"frame_bg\"])\n        self .sidebar_frame .grid (row =0 ,column =0 ,sticky =\"nsw\",padx =(0 ,10 ))\n\n        self .sidebar_frame .grid_rowconfigure (5 ,weight =1 )\n\n        self .logo_label =ctk .CTkLabel (\n        self .sidebar_frame ,text =\"FSim\",\n        font =ctk .CTkFont (size =20 ,weight =\"bold\"),\n        text_color =self .palette [\"text_light\"]\n        )\n        self .logo_label .grid (row =0 ,column =0 ,padx =20 ,pady =(20 ,10 ))\n\n        button_style ={\n        \"fg_color\":self .palette [\"button\"],\n        \"hover_color\":self .palette [\"button_hover\"],\n        \"text_color\":self .palette [\"text_on_button\"]\n        }\n        self .scenario_button =ctk .CTkButton (self .sidebar_frame ,text =\"Escenario\",command =lambda :self .select_frame (\"scenario\"),**button_style )\n        self .scenario_button .grid (row =1 ,column =0 ,padx =20 ,pady =10 )\n        self .results_button =ctk .CTkButton (self .sidebar_frame ,text =\"Resultados\",command =lambda :self .select_frame (\"results\"),**button_style )\n        self .results_button .grid (row =2 ,column =0 ,padx =20 ,pady =10 )\n        self .disk_button =ctk .CTkButton (self .sidebar_frame ,text =\"Disco\",command =lambda :self .select_frame (\"disk\"),**button_style )\n        self .disk_button .grid (row =3 ,column =0 ,padx =20 ,pady =10 )\n\n\n\n        self .charts_button =ctk .CTkButton (self .sidebar_frame ,text =\"Gráficos\",command =lambda :self .select_frame (\"charts\"),**button_style )\n        self .charts_button .grid (row =4 ,column =0 ,padx =20 ,pady =10 )\n\n\n\n\n        self .main_content_frame =ctk .CTkFrame (self ,corner_radius =10 ,fg_color =self .palette [\"frame_bg\"])\n        self .main_content_frame .grid (row =0 ,column =1 ,sticky =\"nsew\")\n        self .main_content_frame .grid_columnconfigure (0 ,weight =1 )\n        self .main_content_frame .grid_rowconfigure (0 ,weight =1 )\n\n\n        self .results_view =ResultsView (self .main_content_frame ,palette =self .palette ,fg_color =\"transparent\")\n        self .disk_view =DiskView (self .main_content_frame ,palette =self .palette ,fg_color =\"transparent\")\n\n\n\n        self .charts_view =ChartsView (self .main_content_frame ,palette =self .palette ,fg_color =\"transparent\")\n\n\n\n        self .scenario_view =ScenarioView (\n        self .main_content_frame ,\n        on_run_start =lambda :self .select_frame (\"disk\"),\n        on_run_complete =self .on_simulation_complete ,\n        on_live_update =self .disk_view .live_update ,\n        palette =self .palette ,\n        fg_color =\"transparent\"\n        )\n\n\n\n\n        self .frames ={\n        \"scenario\":self .scenario_view ,\n        \"results\":self .results_view ,\n        \"disk\":self .disk_view ,\n        \"charts\":self .charts_view ,\n        }\n\n\n        self .select_frame (\"scenario\")\n\n    def select_frame (self ,name :str ):\n\n        for frame_name ,frame in self .frames .items ():\n            if frame_name ==name :\n                frame .grid (row =0 ,column =0 ,sticky =\"nsew\",padx =10 ,pady =10 )\n            else :\n                frame .grid_forget ()\n\n\n    def on_simulation_complete (self ,results :dict ,bitmaps :Optional [Dict [str ,List [int ]]]):\n        \"\"\"\n        Callback que se ejecuta cuando ScenarioView termina una simulación.\n        \"\"\"\n\n        self .results_view .show_results (results )\n\n\n        self .disk_view .show_final_snapshots (bitmaps )\n\n\n        self .charts_view .update_charts (results )\n\n\n\n        self .select_frame (\"results\")", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\ui\\results_view.py": "\nimport customtkinter as ctk \nfrom tkinter import ttk \nimport tkinter as tk \nfrom customtkinter import filedialog \nimport csv \nimport json \nfrom typing import Dict ,Any ,List ,Optional \n\n\nMETRIC_NAMES_ES ={\n\"avg_access_time_ms\":\"Tiempo Promedio de Acceso (ms)\",\"space_usage_pct\":\"Uso de Espacio (%)\",\n\"fragmentation_internal_pct\":\"Fragmentación Interna (%)\",\"fragmentation_external_pct\":\"Fragmentación Externa (%)\",\n\"throughput_ops_per_sec\":\"Operaciones por Segundo (OPS)\",\"hit_miss_ratio\":\"Tasa de Aciertos (%)\",\n\"cpu_usage_pct\":\"Uso de CPU (%)\",\"fairness_index\":\"Índice de Equidad (Desv. Tiempos)\",\n\"elapsed_ms_total\":\"Tiempo Total de Simulación (ms)\",\"ops_count\":\"Total de Operaciones Ejecutadas\",\n\"seeks_total_est\":\"Total de Saltos de Cabezal (Est.)\",\"cpu_time_total_s\":\"Tiempo Total de CPU (s)\"\n}\nMETRIC_ORDER =[\n\"avg_access_time_ms\",\"throughput_ops_per_sec\",\"seeks_total_est\",\"space_usage_pct\",\n\"fragmentation_external_pct\",\"fragmentation_internal_pct\",\"hit_miss_ratio\",\"fairness_index\",\n\"cpu_usage_pct\",\"elapsed_ms_total\",\"ops_count\",\"cpu_time_total_s\",\n]\nKEYS_TO_IGNORE =[\"_basic\",\"_scenario\",\"_seed\",\"files_manifest\",\"op_traces\"]\nMANIFEST_COLUMNS ={\"name\":\"Nombre Archivo\",\"size_blocks\":\"Tamaño (Bloques)\",\"alive\":\"Estado\",\"read_ops\":\"Lecturas\",\"write_ops\":\"Escrituras\"}\n\nclass ResultsView (ctk .CTkFrame ):\n    \"\"\"\n    Vista para mostrar los resultados de la simulación...\n    \"\"\"\n    def __init__ (self ,master ,palette :Dict [str ,str ],**kwargs ):\n        super ().__init__ (master ,**kwargs )\n        self .palette =palette \n        self .configure (fg_color =\"transparent\")\n        self .grid_columnconfigure (0 ,weight =1 )\n        self .grid_rowconfigure (1 ,weight =1 );self .grid_rowconfigure (3 ,weight =2 )\n\n\n        self .title_label =ctk .CTkLabel (self ,text =\"Resultados de la Simulación\",font =ctk .CTkFont (size =20 ,weight =\"bold\"),text_color =self .palette [\"text_light\"])\n        self .title_label .grid (row =0 ,column =0 ,padx =20 ,pady =(0 ,10 ),sticky =\"w\")\n        self .metrics_scroll_frame =ctk .CTkScrollableFrame (self ,fg_color =\"transparent\")\n        self .metrics_scroll_frame .grid (row =1 ,column =0 ,sticky =\"nsew\",padx =0 ,pady =0 )\n        self .metrics_scroll_frame .grid_columnconfigure (0 ,weight =1 )\n        self .metrics_current_row =0 \n        self .manifest_title_frame =ctk .CTkFrame (self ,fg_color =\"transparent\")\n        self .manifest_title_frame .grid (row =2 ,column =0 ,sticky =\"ew\",padx =20 ,pady =(15 ,5 ))\n        self .manifest_title_frame .grid_columnconfigure (0 ,weight =1 )\n        self .manifest_label =ctk .CTkLabel (self .manifest_title_frame ,text =\"Manifiesto de Archivos\",font =ctk .CTkFont (size =18 ,weight =\"bold\"),text_color =self .palette [\"text_light\"])\n        self .manifest_label .grid (row =0 ,column =0 ,sticky =\"w\")\n        export_buttons_frame =ctk .CTkFrame (self .manifest_title_frame ,fg_color =\"transparent\")\n        export_buttons_frame .grid (row =0 ,column =1 ,sticky =\"e\")\n\n\n        button_style_export ={\"fg_color\":self .palette [\"button\"],\"hover_color\":self .palette [\"button_hover\"],\"text_color\":self .palette [\"text_on_button\"],\"width\":220 }\n\n\n\n        self .export_json_button =ctk .CTkButton (export_buttons_frame ,text =\"Exportar resultados (JSON)\",command =self ._export_results_json ,state =\"disabled\",**button_style_export )\n        self .export_json_button .pack (side =\"right\",padx =(5 ,0 ))\n\n\n\n        self .export_csv_button =ctk .CTkButton (export_buttons_frame ,text =\"Exportar manifiesto (CSV)\",command =self ._export_manifest_csv ,state =\"disabled\",**button_style_export )\n        self .export_csv_button .pack (side =\"right\")\n\n\n        self .table_frame =ctk .CTkFrame (self ,fg_color =self .palette [\"app_bg\"])\n        self .table_frame .grid (row =3 ,column =0 ,sticky =\"nsew\",padx =10 ,pady =10 )\n        self .table_frame .grid_rowconfigure (0 ,weight =1 );self .table_frame .grid_columnconfigure (0 ,weight =1 )\n\n        style =ttk .Style ();style .theme_use (\"clam\");style .configure (\"Treeview\",background =self .palette [\"app_bg\"],foreground =self .palette [\"text_light\"],fieldbackground =self .palette [\"app_bg\"],rowheight =25 ,bordercolor =self .palette [\"button\"],borderwidth =1 );style .map ('Treeview',background =[('selected',self .palette [\"button\"])],foreground =[('selected',self .palette [\"text_on_button\"])]);style .configure (\"Treeview.Heading\",background =self .palette [\"button\"],foreground =self .palette [\"text_on_button\"],relief =\"flat\",font =('Arial',10 ,'bold'));style .map (\"Treeview.Heading\",background =[('active',self .palette [\"button_hover\"])])\n        self .tree =ttk .Treeview (self .table_frame ,columns =list (MANIFEST_COLUMNS .keys ()),show =\"headings\")\n        for key ,header_text in MANIFEST_COLUMNS .items ():\n            anchor =tk .W ;width =100 ;stretch =tk .NO \n            if key ==\"name\":width =250 ;stretch =tk .YES \n            elif key ==\"size_blocks\":width =120 ;anchor =tk .E \n            elif key ==\"alive\":width =80 ;anchor =tk .CENTER \n            elif key ==\"read_ops\"or key ==\"write_ops\":width =80 ;anchor =tk .E \n            self .tree .heading (key ,text =header_text ,anchor =anchor )\n            self .tree .column (key ,anchor =anchor ,width =width ,stretch =stretch )\n        vsb =ttk .Scrollbar (self .table_frame ,orient =\"vertical\",command =self .tree .yview );hsb =ttk .Scrollbar (self .table_frame ,orient =\"horizontal\",command =self .tree .xview );self .tree .configure (yscrollcommand =vsb .set ,xscrollcommand =hsb .set );self .tree .grid (row =0 ,column =0 ,sticky =\"nsew\");vsb .grid (row =0 ,column =1 ,sticky =\"ns\");hsb .grid (row =1 ,column =0 ,sticky =\"ew\")\n\n        self ._current_manifest_data :List [Dict [str ,Any ]]=[]\n        self ._current_summaries_data :Optional [Dict [str ,Any ]]=None \n        self ._show_placeholder ()\n\n\n\n\n    def _clear_results (self ):\n        \"\"\"Limpia métricas, tabla y deshabilita botones.\"\"\"\n\n\n\n        for widget in list (self .metrics_scroll_frame .winfo_children ()):\n            widget .destroy ()\n        self .metrics_current_row =0 \n\n\n\n        for item in self .tree .get_children ():\n            self .tree .delete (item )\n\n\n        self ._current_manifest_data =[]\n        self ._current_summaries_data =None \n\n\n        self .export_csv_button .configure (state =\"disabled\")\n        self .export_json_button .configure (state =\"disabled\")\n\n\n    def _show_placeholder (self ):\n        \"\"\"Muestra el mensaje inicial.\"\"\"\n        self ._clear_results ()\n        label =ctk .CTkLabel (self .metrics_scroll_frame ,text =\"Ejecuta una simulación...\",text_color =self .palette [\"text_light\"])\n        label .grid (row =self .metrics_current_row ,column =0 ,padx =20 ,pady =20 )\n        self .metrics_current_row +=1 \n        self .manifest_label .configure (text =\"Manifiesto de Archivos\")\n\n    def _show_error (self ,error_msg :str ):\n        \"\"\"Muestra un mensaje de error estilizado.\"\"\"\n        self ._clear_results ()\n        label =ctk .CTkLabel (self .metrics_scroll_frame ,text =\"Error en la Simulación:\",text_color =\"#FF5555\",font =ctk .CTkFont (size =16 ,weight =\"bold\"))\n        label .grid (row =self .metrics_current_row ,column =0 ,padx =20 ,pady =(10 ,5 ),sticky =\"w\")\n        self .metrics_current_row +=1 \n        error_text =ctk .CTkTextbox (self .metrics_scroll_frame ,activate_scrollbars =False ,text_color =self .palette [\"text_light\"])\n        error_text .insert (\"0.0\",error_msg )\n        error_text .configure (state =\"disabled\",fg_color =\"transparent\",font =ctk .CTkFont (family =\"monospace\"))\n        error_text .configure (height =len (error_msg .split ('\\n'))*20 +20 )\n        error_text .grid (row =self .metrics_current_row ,column =0 ,padx =20 ,pady =(0 ,20 ),sticky =\"ew\")\n        self .metrics_current_row +=1 \n        self .manifest_label .configure (text =\"Manifiesto de Archivos (No disponible)\")\n\n    def _add_metric_row (self ,master_frame ,key :str ,value :Any ):\n        \"\"\"Añade una fila de métrica (Nombre: Valor) al frame de métricas.\"\"\"\n\n        display_name =METRIC_NAMES_ES .get (key ,key );\n        if isinstance (value ,float ):display_value =f\"{value :.3f}\"\n        else :display_value =str (value )\n        row_frame =ctk .CTkFrame (master_frame ,fg_color =\"transparent\");row_frame .pack (fill =\"x\",padx =10 ,pady =1 );row_frame .grid_columnconfigure (0 ,weight =1 );row_frame .grid_columnconfigure (1 ,weight =1 )\n        name_label =ctk .CTkLabel (row_frame ,text =f\"{display_name }:\",anchor =\"w\",text_color =self .palette [\"text_light\"]);name_label .grid (row =0 ,column =0 ,sticky =\"w\")\n        value_label =ctk .CTkLabel (row_frame ,text =display_value ,anchor =\"e\",text_color =self .palette [\"text_light\"],font =ctk .CTkFont (weight =\"bold\"));value_label .grid (row =0 ,column =1 ,sticky =\"e\")\n\n\n    def _add_strategy_card (self ,strategy_name :str ,metrics :Dict [str ,Any ]):\n        \"\"\"Añade una \"tarjeta\" de métricas agregadas.\"\"\"\n\n        title_label =ctk .CTkLabel (self .metrics_scroll_frame ,text =f\"Estrategia: {strategy_name .upper ()}\",font =ctk .CTkFont (size =18 ,weight =\"bold\"),text_color =self .palette [\"text_light\"]);title_label .grid (row =self .metrics_current_row ,column =0 ,padx =5 ,pady =(20 ,10 ),sticky =\"w\");self .metrics_current_row +=1 \n        card_frame =ctk .CTkFrame (self .metrics_scroll_frame ,border_width =1 ,border_color =self .palette [\"button_hover\"],fg_color =self .palette [\"app_bg\"]);card_frame .grid (row =self .metrics_current_row ,column =0 ,sticky =\"ew\",padx =5 ,pady =5 );self .metrics_current_row +=1 \n        for key in METRIC_ORDER :\n            if key in metrics and key not in KEYS_TO_IGNORE :self ._add_metric_row (card_frame ,key ,metrics [key ])\n        for key ,value in metrics .items ():\n            if key not in METRIC_ORDER and key not in KEYS_TO_IGNORE :self ._add_metric_row (card_frame ,key ,value )\n        ctk .CTkFrame (card_frame ,height =10 ,fg_color =\"transparent\").pack ()\n\n\n    def _populate_manifest_table (self ,manifest_data :List [Dict [str ,Any ]]):\n        \"\"\"Llena la tabla Treeview con los datos del manifiesto.\"\"\"\n\n\n        for item in self .tree .get_children ():\n            self .tree .delete (item )\n        self ._current_manifest_data =manifest_data \n\n        for i ,file_info in enumerate (manifest_data ):\n            values =[];tag ='even'if i %2 ==0 else 'odd'\n            for key in MANIFEST_COLUMNS .keys ():\n                value =file_info .get (key ,\"-\")\n                if key ==\"alive\":value =\"Vivo\"if value else \"Borrado\"\n                values .append (value )\n            self .tree .insert (\"\",tk .END ,values =values ,tags =(tag ,))\n\n        self .export_csv_button .configure (state =\"normal\"if manifest_data else \"disabled\")\n\n    def _export_manifest_csv (self ):\n        \"\"\"Exporta los datos del manifiesto actual a un archivo CSV.\"\"\"\n\n        if not self ._current_manifest_data :return \n        filepath =filedialog .asksaveasfilename (title =\"Guardar Manifiesto como CSV\",defaultextension =\".csv\",filetypes =[(\"CSV\",\"*.csv\"),(\"Todos\",\"*.*\")])\n        if not filepath :return \n        try :\n            headers =list (MANIFEST_COLUMNS .keys ())\n            with open (filepath ,\"w\",newline =\"\",encoding =\"utf-8\")as f :\n                writer =csv .DictWriter (f ,fieldnames =headers )\n                writer .writerow (MANIFEST_COLUMNS )\n                for file_info in self ._current_manifest_data :\n                    row_to_write ={h :file_info .get (h ,\"\")for h in headers }\n                    if 'alive'in row_to_write :row_to_write ['alive']=\"Vivo\"if row_to_write ['alive']else \"Borrado\"\n                    writer .writerow (row_to_write )\n            print (f\"Manifiesto exportado a {filepath }\")\n        except Exception as e :print (f\"Error al exportar CSV: {e }\")\n\n\n    def _export_results_json (self ):\n        \"\"\"Exporta los datos de summaries (SOLO MÉTRICAS) a un archivo JSON.\"\"\"\n        if not self ._current_summaries_data :\n            print (\"No hay datos de resultados para exportar.\")\n\n            return \n\n        filepath =filedialog .asksaveasfilename (\n        title =\"Guardar Resumen de Métricas como JSON\",\n        defaultextension =\".json\",\n        filetypes =[(\"JSON\",\"*.json\"),(\"Todos\",\"*.*\")]\n        )\n        if not filepath :\n            return \n\n        try :\n\n            filtered_summaries ={}\n\n\n            for strategy ,metrics in self ._current_summaries_data .items ():\n\n                filtered_metrics ={}\n\n                for key ,value in metrics .items ():\n\n\n                    if key not in KEYS_TO_IGNORE and not isinstance (value ,list ):\n                        filtered_metrics [key ]=value \n\n\n                if filtered_metrics :\n                    filtered_summaries [strategy ]=filtered_metrics \n\n\n            if not filtered_summaries :\n                 print (\"No hay métricas resumidas para exportar después del filtrado.\")\n\n                 return \n\n\n            with open (filepath ,\"w\",encoding =\"utf-8\")as f :\n                json .dump (filtered_summaries ,f ,indent =2 )\n\n            print (f\"Resumen de métricas exportado exitosamente a {filepath }\")\n\n\n        except Exception as e :\n            print (f\"Error al exportar JSON: {e }\")\n\n\n\n\n    def show_results (self ,summaries :Optional [Dict [str ,Any ]]):\n        \"\"\"\n        Punto de entrada principal. Muestra métricas, llena tabla y guarda summaries.\n        \"\"\"\n\n        self ._clear_results ()\n        self ._current_summaries_data =summaries \n\n\n        if summaries is None :\n            self ._show_placeholder ()\n            return \n        if \"error\"in summaries :\n            self ._show_error (summaries [\"error\"])\n            return \n        if not summaries :\n            self ._show_placeholder ()\n            return \n\n\n        first_manifest =None \n        found_valid_strategy =False \n        for strategy_name ,metrics in summaries .items ():\n\n            if strategy_name .startswith (\"_\"):\n                continue \n\n\n            self ._add_strategy_card (strategy_name ,metrics )\n            found_valid_strategy =True \n\n\n            if first_manifest is None and \"files_manifest\"in metrics :\n                 potential_manifest =metrics .get (\"files_manifest\")\n\n                 if isinstance (potential_manifest ,list ):\n                      first_manifest =potential_manifest \n\n\n        if isinstance (first_manifest ,list ):\n            self ._populate_manifest_table (first_manifest )\n            self .manifest_label .configure (text =f\"Manifiesto de Archivos ({len (first_manifest )} total)\")\n        else :\n            self ._populate_manifest_table ([])\n            self .manifest_label .configure (text =\"Manifiesto de Archivos (No disponible)\")\n\n\n        can_export_csv =bool (self ._current_manifest_data )\n        can_export_json =found_valid_strategy \n        self .export_csv_button .configure (state =\"normal\"if can_export_csv else \"disabled\")\n        self .export_json_button .configure (state =\"normal\"if can_export_json else \"disabled\")\n", "C:\\Users\\marec\\Downloads\\filesystem-sim-stubs\\src\\fsim\\ui\\scenario_view.py": "\nimport customtkinter as ctk \nfrom customtkinter import filedialog \nimport threading \nimport json \nimport csv \nfrom typing import Callable ,Dict ,Any ,List ,Optional \n\n\nfrom ..sim .runner import run_simulation ,STRATEGIES \nfrom ..sim .scenario_definitions import available_scenarios ,get_config \n\n\nSTRATEGY_MAP_ES ={\n\"contiguous\":\"Asignación Contigua\",\n\"linked\":\"Asignación Enlazada\",\n\"indexed\":\"Asignación Indexada\",\n\"all\":\"Todas las Estrategias\"\n}\nSTRATEGY_MAP_EN ={v :k for k ,v in STRATEGY_MAP_ES .items ()}\nSCENARIO_MAP_ES :Dict [str ,str ]={}\nSCENARIO_MAP_EN :Dict [str ,str ]={}\n\n\nclass ScenarioView (ctk .CTkFrame ):\n    \"\"\"\n    Vista para configurar y lanzar una simulación.\n    Incluye lógica para carga de archivos manuales.\n    \"\"\"\n\n    def __init__ (self ,\n    master ,\n    on_run_start :Callable [[],None ],\n    on_run_complete :Callable [[Dict [str ,Any ],Optional [Dict [str ,List [int ]]]],None ],\n    on_live_update :Callable [[str ,List [int ]],None ],\n    palette :Dict [str ,str ],\n    **kwargs ):\n        super ().__init__ (master ,**kwargs )\n        self .on_run_start =on_run_start \n        self .on_run_complete =on_run_complete \n        self .on_live_update =on_live_update \n        self .palette =palette \n\n        self .manual_file_rows :List [tuple ]=[]\n\n        self .grid_columnconfigure (0 ,weight =1 )\n\n        config_frame =ctk .CTkFrame (self ,fg_color =\"transparent\")\n        config_frame .pack (pady =20 ,padx =20 ,fill =\"x\",expand =False )\n\n        config_frame .grid_columnconfigure (0 ,weight =0 ,minsize =140 )\n        config_frame .grid_columnconfigure (1 ,weight =1 )\n\n\n        self .label_style ={\"text_color\":self .palette [\"text_light\"]}\n        button_style ={\n        \"fg_color\":self .palette [\"button\"],\n        \"hover_color\":self .palette [\"button_hover\"],\n        \"text_color\":self .palette [\"text_on_button\"]\n        }\n        option_style ={\n        \"fg_color\":self .palette [\"button\"],\n        \"button_color\":self .palette [\"button\"],\n        \"button_hover_color\":self .palette [\"button_hover\"],\n        \"text_color\":self .palette [\"text_on_button\"],\n        \"dropdown_fg_color\":self .palette [\"frame_bg\"],\n        \"dropdown_hover_color\":self .palette [\"button_hover\"],\n        \"dropdown_text_color\":self .palette [\"text_light\"]\n        }\n        checkbox_style ={\n        \"text_color\":self .palette [\"text_light\"],\n        \"border_color\":self .palette [\"button\"],\n        \"hover_color\":self .palette [\"button_hover\"],\n        \"fg_color\":self .palette [\"button\"]\n        }\n        self .entry_style ={\n        \"border_color\":self .palette [\"button\"],\n        \"text_color\":self .palette [\"text_light\"],\n        \"fg_color\":self .palette [\"app_bg\"]\n        }\n\n        current_row =0 \n\n\n        self .strategy_label =ctk .CTkLabel (config_frame ,text =\"Estrategia:\",anchor =\"w\",**self .label_style )\n        self .strategy_label .grid (row =current_row ,column =0 ,padx =0 ,pady =(10 ,5 ),sticky =\"w\")\n        strategy_display_names =list (STRATEGY_MAP_ES .values ())\n        default_strategy_display =STRATEGY_MAP_ES [\"contiguous\"]\n        self .strategy_var =ctk .StringVar (value =default_strategy_display )\n        self .strategy_menu =ctk .CTkOptionMenu (\n        config_frame ,variable =self .strategy_var ,values =strategy_display_names ,**option_style \n        )\n        self .strategy_menu .grid (row =current_row ,column =1 ,padx =0 ,pady =(10 ,5 ),sticky =\"ew\")\n        current_row +=1 \n\n\n        self .scenario_label =ctk .CTkLabel (config_frame ,text =\"Escenario Base:\",anchor =\"w\",**self .label_style )\n        self .scenario_label .grid (row =current_row ,column =0 ,padx =0 ,pady =5 ,sticky =\"w\")\n        self ._load_scenarios_maps ()\n        scenario_display_names =list (SCENARIO_MAP_ES .values ())\n        default_scenario_display =scenario_display_names [0 ]if scenario_display_names else \"Sin Escenarios\"\n        self .scenario_var =ctk .StringVar (value =default_scenario_display )\n        self .scenario_menu =ctk .CTkOptionMenu (\n        config_frame ,variable =self .scenario_var ,values =scenario_display_names ,**option_style \n        )\n        self .scenario_menu .grid (row =current_row ,column =1 ,padx =0 ,pady =5 ,sticky =\"ew\")\n        current_row +=1 \n\n\n        self .slow_mo_var =ctk .BooleanVar (value =True )\n        self .slow_mo_check =ctk .CTkCheckBox (\n        config_frame ,\n        text =\"Activar visualización lenta (Modo Demo)\",\n        variable =self .slow_mo_var ,\n        **checkbox_style \n        )\n        self .slow_mo_check .grid (row =current_row ,column =0 ,columnspan =2 ,padx =0 ,pady =10 ,sticky =\"w\")\n        current_row +=1 \n\n\n        sep =ctk .CTkFrame (config_frame ,height =2 ,border_width =0 ,fg_color =self .palette [\"button\"])\n        sep .grid (row =current_row ,column =0 ,columnspan =2 ,sticky =\"ew\",pady =15 )\n        current_row +=1 \n\n\n        self .workload_mode_label =ctk .CTkLabel (config_frame ,text =\"Carga de Archivos:\",anchor =\"w\",**self .label_style )\n        self .workload_mode_label .grid (row =current_row ,column =0 ,padx =0 ,pady =10 ,sticky =\"w\")\n        self .workload_mode_var =ctk .StringVar (value =\"Aleatorio (Seed)\")\n        self .workload_mode_toggle =ctk .CTkSegmentedButton (\n        config_frame ,\n        values =[\"Aleatorio (Seed)\",\"Manual (Lista)\"],\n        variable =self .workload_mode_var ,\n        command =self ._on_workload_mode_change ,\n        text_color =self .palette [\"text_on_button\"],\n        selected_color =self .palette [\"button\"],\n        selected_hover_color =self .palette [\"button_hover\"],\n        unselected_color =self .palette [\"frame_bg\"],\n        unselected_hover_color =self .palette [\"app_bg\"],\n\n        border_width =0 \n        )\n        self .workload_mode_toggle .grid (row =current_row ,column =1 ,sticky =\"ew\",pady =10 )\n\n        self .workload_panels_row =current_row +1 \n        current_row +=1 \n\n\n\n        self .seed_label =ctk .CTkLabel (config_frame ,text =\"Seed (Semilla):\",**self .label_style )\n\n        self .seed_frame =ctk .CTkFrame (config_frame ,fg_color =\"transparent\")\n        self .seed_entry =ctk .CTkEntry (self .seed_frame ,placeholder_text =\"Vacío para aleatorio\",**self .entry_style )\n        self .seed_entry .pack (fill =\"x\",expand =True )\n\n\n        self .manual_frame =ctk .CTkFrame (config_frame ,fg_color =\"transparent\")\n\n        self .manual_frame .grid_columnconfigure (0 ,weight =1 )\n\n\n        manual_controls_frame =ctk .CTkFrame (self .manual_frame ,fg_color =\"transparent\")\n        manual_controls_frame .grid (row =0 ,column =0 ,sticky =\"ew\")\n        self .add_file_button =ctk .CTkButton (manual_controls_frame ,text =\"Añadir Archivo\",command =self ._add_file_row ,**button_style )\n        self .add_file_button .pack (side =\"left\",padx =(0 ,10 ))\n        self .import_button =ctk .CTkButton (manual_controls_frame ,text =\"Importar CSV/JSON\",command =self ._import_files ,**button_style )\n        self .import_button .pack (side =\"left\",padx =10 )\n        self .respect_only_var =ctk .BooleanVar (value =True )\n        self .respect_only_check =ctk .CTkCheckBox (\n        manual_controls_frame ,\n        text =\"Usar solo esta lista (ignorar aleatorios)\",\n        variable =self .respect_only_var ,\n        **checkbox_style \n        )\n        self .respect_only_check .pack (side =\"left\",padx =20 )\n        header_frame =ctk .CTkFrame (self .manual_frame ,fg_color =\"transparent\")\n        header_frame .grid (row =1 ,column =0 ,sticky =\"ew\",pady =(10 ,0 ))\n        header_frame .grid_columnconfigure (0 ,weight =2 )\n        header_frame .grid_columnconfigure (1 ,weight =1 )\n        header_frame .grid_columnconfigure (2 ,minsize =40 )\n        ctk .CTkLabel (header_frame ,text =\"Nombre de Archivo\",**self .label_style ,font =ctk .CTkFont (weight =\"bold\")).grid (row =0 ,column =0 )\n        ctk .CTkLabel (header_frame ,text =\"Tamaño (Bloques)\",**self .label_style ,font =ctk .CTkFont (weight =\"bold\")).grid (row =0 ,column =1 )\n        self .file_list_frame =ctk .CTkScrollableFrame (self .manual_frame ,height =150 ,fg_color =self .palette [\"app_bg\"])\n        self .file_list_frame .grid (row =2 ,column =0 ,sticky =\"ew\",pady =(5 ,10 ))\n        self .file_list_frame .grid_columnconfigure (0 ,weight =1 )\n\n        current_row +=1 \n\n\n        self .run_button =ctk .CTkButton (config_frame ,text =\"Ejecutar Simulación\",command =self ._start_simulation ,**button_style )\n        self .run_button .grid (row =current_row ,column =0 ,columnspan =2 ,padx =0 ,pady =20 )\n        current_row +=1 \n\n\n        self .status_label =ctk .CTkLabel (config_frame ,text =\"\",text_color =self .palette [\"text_light\"])\n        self .status_label .grid (row =current_row ,column =0 ,columnspan =2 ,padx =0 ,pady =0 )\n\n\n        self ._on_workload_mode_change (\"Aleatorio (Seed)\")\n\n\n    def _load_scenarios_maps (self ):\n        \"\"\"Carga y traduce los escenarios.\"\"\"\n        global SCENARIO_MAP_ES ,SCENARIO_MAP_EN \n        try :\n            scenarios =available_scenarios (\"data/scenarios.json\")\n            SCENARIO_MAP_ES .clear ()\n            SCENARIO_MAP_EN .clear ()\n            for key ,description in scenarios .items ():\n                friendly_name =\"\"\n                if key ==\"mix-small-large\":friendly_name =\"Mezcla Pequeños y Grandes\"\n                elif key ==\"seq-vs-rand\":friendly_name =\"Acceso Secuencial vs Aleatorio\"\n                elif key ==\"frag-intensive\":friendly_name =\"Fragmentación Intensiva\"\n                else :friendly_name =description .split (\",\")[0 ]\n                SCENARIO_MAP_ES [key ]=friendly_name \n                SCENARIO_MAP_EN [friendly_name ]=key \n        except Exception as e :\n            print (f\"Error cargando scenarios.json: {e }\")\n\n    def _on_workload_mode_change (self ,mode :str ):\n        \"\"\"Muestra u oculta los paneles de Seed o Manual.\"\"\"\n        row_to_use =self .workload_panels_row \n\n\n        if mode ==\"Aleatorio (Seed)\":\n\n            self .seed_label .grid (row =row_to_use ,column =0 ,padx =0 ,pady =5 ,sticky =\"w\")\n            self .seed_frame .grid (row =row_to_use ,column =1 ,sticky =\"ew\",pady =5 )\n\n            self .manual_frame .grid_forget ()\n        else :\n\n            self .seed_label .grid_forget ()\n            self .seed_frame .grid_forget ()\n\n            self .manual_frame .grid (row =row_to_use ,column =0 ,columnspan =2 ,sticky =\"ew\",pady =5 )\n\n\n    def _add_file_row (self ,name :str =\"\",size :Any =\"\"):\n        row_frame =ctk .CTkFrame (self .file_list_frame ,fg_color =\"transparent\")\n        row_frame .pack (fill =\"x\",pady =2 )\n        row_frame .grid_columnconfigure (0 ,weight =2 )\n        row_frame .grid_columnconfigure (1 ,weight =1 )\n        row_frame .grid_columnconfigure (2 ,minsize =40 )\n\n        name_entry =ctk .CTkEntry (row_frame ,**self .entry_style )\n        name_entry .insert (0 ,name )\n        name_entry .grid (row =0 ,column =0 ,sticky =\"ew\",padx =(0 ,5 ))\n\n        size_entry =ctk .CTkEntry (row_frame ,**self .entry_style )\n        size_entry .insert (0 ,str (size ))\n        size_entry .grid (row =0 ,column =1 ,sticky =\"ew\",padx =5 )\n\n        remove_btn =ctk .CTkButton (\n        row_frame ,text =\"X\",width =28 ,height =28 ,\n        fg_color =\"#D00000\",hover_color =\"#FF0000\",text_color =\"white\"\n        )\n        remove_btn .configure (command =lambda f =row_frame :self ._remove_file_row (f ))\n        remove_btn .grid (row =0 ,column =2 ,padx =(5 ,0 ))\n        self .manual_file_rows .append ((row_frame ,name_entry ,size_entry ))\n\n    def _remove_file_row (self ,row_frame :ctk .CTkFrame ):\n        row_to_remove =None \n        for row_tuple in self .manual_file_rows :\n            if row_tuple [0 ]==row_frame :\n                row_to_remove =row_tuple \n                break \n        if row_to_remove :\n            self .manual_file_rows .remove (row_to_remove )\n        row_frame .destroy ()\n\n    def _clear_file_rows (self ):\n        while self .manual_file_rows :\n            row_tuple =self .manual_file_rows .pop ()\n            row_tuple [0 ].destroy ()\n\n    def _import_files (self ):\n        filepath =filedialog .askopenfilename (\n        title =\"Importar Archivos Manuales\",\n        filetypes =[(\"JSON/CSV\",\"*.json *.csv\"),(\"Todos\",\"*.*\")]\n        )\n        if not filepath :\n            return \n        try :\n            self ._clear_file_rows ()\n            user_files =[]\n            if filepath .endswith (\".json\"):\n                with open (filepath ,\"r\",encoding =\"utf-8\")as f :\n                    data =json .load (f )\n                    if not isinstance (data ,list ):\n                        raise ValueError (\"El JSON debe ser una *lista* de objetos.\")\n                    for item in data :\n                        user_files .append ({\n                        \"name\":str (item [\"name\"]),\n                        \"size_blocks\":int (item [\"size_blocks\"])\n                        })\n            elif filepath .endswith (\".csv\"):\n                with open (filepath ,\"r\",encoding =\"utf-8\")as f :\n                    reader =csv .DictReader (f )\n                    for row in reader :\n                        user_files .append ({\n                        \"name\":str (row [\"name\"]),\n                        \"size_blocks\":int (row [\"size_blocks\"])\n                        })\n            else :\n                raise ValueError (\"Archivo debe ser .json o .csv\")\n            for f in user_files :\n                self ._add_file_row (f [\"name\"],f [\"size_blocks\"])\n            self .status_label .configure (text =f\"Éxito: Se importaron {len (user_files )} archivos.\",text_color =self .palette [\"text_light\"])\n        except Exception as e :\n            print (f\"Error al importar: {e }\")\n            self .status_label .configure (text =f\"Error al importar: {e }\",text_color =\"#FF5555\")\n\n    def _collect_manual_files (self )->Optional [List [Dict [str ,Any ]]]:\n        user_files =[]\n        for i ,(row_frame ,name_entry ,size_entry )in enumerate (self .manual_file_rows ):\n            name =name_entry .get ().strip ()\n            size_str =size_entry .get ().strip ()\n            if not name or not size_str :\n                self .status_label .configure (text =f\"Error: Fila {i +1 } está incompleta.\",text_color =\"#FF5555\")\n                return None \n            try :\n                size =int (size_str )\n                if size <=0 :\n                    raise ValueError ()\n                user_files .append ({\"name\":name ,\"size_blocks\":size })\n            except ValueError :\n                self .status_label .configure (text =f\"Error: Fila {i +1 }, el tamaño '{size_str }' debe ser un número > 0.\",text_color =\"#FF5555\")\n                return None \n        return user_files \n\n\n    def _start_simulation (self ):\n        self .run_button .configure (state =\"disabled\",text =\"Ejecutando...\")\n        self .status_label .configure (text =\"Iniciando simulación...\",text_color =self .palette [\"text_light\"])\n        if self .on_run_start :\n            self .on_run_start ()\n        strategy_display =self .strategy_var .get ()\n        scenario_display =self .scenario_var .get ()\n        strategy_key =STRATEGY_MAP_EN .get (strategy_display )\n        scenario_key =SCENARIO_MAP_EN .get (scenario_display )\n        if strategy_key is None or scenario_key is None :\n            self .after (0 ,self ._simulation_error ,Exception (f\"Clave no encontrada para '{strategy_display }' o '{scenario_display }'\"))\n            return \n        slowdown_val =5 if self .slow_mo_var .get ()else 0 \n        mode =self .workload_mode_var .get ()\n        user_files_list :Optional [List [Dict [str ,Any ]]]=None \n        respect_only_flag :bool =False \n        seed_val :Optional [int ]=None \n        if mode ==\"Manual (Lista)\":\n            user_files_list =self ._collect_manual_files ()\n            if user_files_list is None :\n                self .run_button .configure (state =\"normal\",text =\"Ejecutar Simulación\")\n                return \n            respect_only_flag =self .respect_only_var .get ()\n        else :\n            seed_str =self .seed_entry .get ().strip ()\n            if seed_str .isdigit ():\n                seed_val =int (seed_str )\n        thread =threading .Thread (\n        target =self ._run_simulation_thread ,\n        args =(\n        strategy_key ,\n        scenario_key ,\n        slowdown_val ,\n        user_files_list ,\n        respect_only_flag ,\n        seed_val \n        ),\n        daemon =True \n        )\n        thread .start ()\n\n    def _run_simulation_thread (\n    self ,\n    strategy_key :str ,\n    scenario_key :str ,\n    slowdown_val :int ,\n    user_files_list :Optional [List [Dict [str ,Any ]]],\n    respect_only_flag :bool ,\n    seed_val :Optional [int ]\n    ):\n        try :\n            results ,bitmaps =run_simulation (\n            strategy_name =strategy_key ,\n            scenario =scenario_key ,\n            scenarios_path =\"data/scenarios.json\",\n            seed =seed_val ,\n            overrides ={},\n            out =None ,\n            on_bitmap_update =self .on_live_update ,\n            ui_slowdown_ms =slowdown_val ,\n            user_files =user_files_list ,\n            respect_user_files_only =respect_only_flag \n            )\n            self .after (0 ,self ._simulation_complete ,results ,bitmaps )\n        except Exception as e :\n            print (f\"Error en el hilo de simulación: {e }\")\n            self .after (0 ,self ._simulation_error ,e )\n\n    def _simulation_complete (self ,results :Dict [str ,Any ],bitmaps :Optional [Dict [str ,List [int ]]]):\n        strategy_display =self .strategy_var .get ()\n        self .status_label .configure (text =f\"Simulación completada. Resultados para '{strategy_display }'.\",text_color =self .palette [\"text_light\"])\n        self .run_button .configure (state =\"normal\",text =\"Ejecutar Simulación\")\n        if self .on_run_complete :\n            self .on_run_complete (results ,bitmaps )\n\n    def _simulation_error (self ,error :Exception ):\n        self .status_label .configure (text =f\"Error: {error }\",text_color =\"#FF5555\")\n        self .run_button .configure (state =\"normal\",text =\"Ejecutar Simulación\")\n        if self .on_run_complete :\n            self .on_run_complete ({\"error\":str (error )},None )"}